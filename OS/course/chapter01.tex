\chapter{操作系统概述}
\section{什么是操作系统}
\subsection{操作系统的定义}
\begin{enumerate}
\item 操作系统是一个控制程序
	\begin{itemize}
		\item 一个系统软件
		\item 控制程序执行过程，防止错误和计算机的不当使用
		\item 执行用户程序，给用户程序提供各种服务
		\item 方便用户使用计算机系统
	\end{itemize}
\item 操作系统是一个资源管理器
	\begin{itemize}
		\item 应用程序与硬件之间的中间层
		\item 管理各种计算机软硬件资源
		\item 提供访问计算机软硬件资源的高效手段
		\item 解决资源访问冲突，确保资源公平使用
	\end{itemize}
\end{enumerate}
\subsection{操作系统软件的组成}
\begin{enumerate}
	\item Shell：命令行接口
	\item GUI：图形用户接口
	\subitem WIMP：视窗Window、图标Icon、选单Menu、指标Pointer
	\item Kernel：操作系统的内部
	\subitem 执行各种资源管理等功能
\end{enumerate}
\subsection{操作系统内核特征}
\begin{itemize}
	\item 并发
	\subitem 计算机系统中同时存在多个运行的程序，需要OS管理和调度；
	\item 共享
	\subitem “同时”访问
	\subitem 互斥共享
	\item 虚拟
	\subitem 利用多道程序设计技术，让每个用户都觉得有一个计算机专门为TA服务
	\item 异步
	\subitem 程序的执行不是一贯到底，而是走走停停，向前推进的速度不可预知
	\subitem 只要运行环境相同，OS需要保证程序运行的结果也要相同
\end{itemize}

\section{为什么学习操作系统}
操作系统：计算机科学研究的基石之一。
\par 会议：
\begin{itemize}
	\item ACM操作系统原理研讨会SOSP
	\item USENIX操作系统设计和实现研讨会OSD
\end{itemize}
\section{操作系统实例}
\noindent UNIX BSD\\
Linux\\
Windows
\section{操作系统的演变}
主要功能：硬件抽象和协调管理\par
原则：设计随着各种相关技术的改变而做出一定的改变\\
\begin{itemize}
	\item 单用户系统
	\item 批处理系统
	\item 多道程序系统
	\item 分时系统
	\item 个人计算机
	\item 分布式计算
\end{itemize}
\subsection{单用户系统(45-55)}
操作系统=装载器+通用子程序库\\
\par 问题：昂贵组件的低利用率\par
$\text{利用率}=\dfrac{\text{执行时间}}{\text{执行时间}+\text{读卡时间}}$
\subsection{批处理系统(55-65)}
顺序执行与批处理
\subsection{多道程序(65-80)}
保持多个工作在内存中并且在各工作间复用CPU
\subsection{分时系统(70-)}
定时中断用于工作对CPU的复用
\subsection{个人计算机}
\begin{itemize}
	\item 单用户
	\item 利用率已不再是关注点
	\item 重点是用户界面和多媒体
	\item 很老的服务和功能不存在
\end{itemize}
从开始的：OS为一个简单的服务提供者，到现在：支持协调和沟通的多应用系统。
\subsection{分布式计算}
\begin{itemize}
	\item 网络支持成为一个重要的功能
	\item 通常支持分布式服务：跨多系统的数据共享和协调
	\item 可能使用多个处理器：松、紧耦合系统
	\item 高可用性与可靠性的要求
\end{itemize}
演变过程：\\
主机型计算(Mainframe computing) $\rightarrow$个人机计算(Personal computing)$\rightarrow$  网络计算(Internet computing)$\rightarrow$ 普适计算(Pervasive computing)，移动计算，云计算，大数据处理
\section{操作系统的结构}
\subsection{简单结构}
MS-DOS：在最小的空间，设计用于提供大部分功能
\begin{itemize}
	\item 没有拆分为模块
	\item 虽然MS-DOS在接口和功能水平没有很好地分离，主要使用汇编编写
\end{itemize}
\subsection{分层结构}
\begin{itemize}
	\item 将OS分为多层
	\begin{itemize}
		\item 每层建立在底层之上
		\item 最底层layer 0是硬件
		\item 最高层layer N是用户界面
	\end{itemize}
	\item 每一层仅使用更低一层的功能和服务
\end{itemize}
主要贡献：可移植性\\
UNIX在1972设计，高级系统编程语言C语言，创建了可移植操作系统的概念。\\
\subsection{微内核}
分层带来效率低的问题，因此提出\textbf{微内核}(Microkernel)：尽可能多的功能放到用户态，内核只保留进程间通讯和底层硬件支持
\begin{itemize}
	\item 尽可能把内核功能移到用户空间
	\item 用户模块之间的通信使用消息传递
	\item 优点：灵活，安全
	\item 缺点：性能
\end{itemize}
\subsection{外核结构}
在内核中方更少的东西，起到资源的隔离，资源管理交给应用态的代码去完成。
\begin{itemize}
	\item 让内核分配机器的物理资源给多个应用程序，并让每个程序决定如何处理这些资源；
	\item 程序能链接到操作系统库(libOS)实现了操作系统抽象
	\item 保护与控制分离
\end{itemize}
\subsection{VMM虚拟机管理器}
VMM虚拟机管理器将单独的机器接口转换成很多的虚拟机，每个虚拟机都是一个原始
计算机系统的有效副本，并能完成所有的处理类指令。
\par 操作系统和VMM打交道，VMM实现硬件交互，VMM资源的隔离，操作系统负责资源的管理。

\section{问题}
\begin{enumerate}
	\item 程序正在试图读取某个磁盘的第100个逻辑块，使用操作系统提供的（ A ）接口
	\begin{enumerate}[A]
		\item 系统调用
		\item 图形用户
		\item 原语
		\item 键盘命令
	\end{enumerate}
操作系统作为用户和计算机硬件系统之间的接口，用户可以通过3种方式使用计算机，命令方式、系统调用方式、图形方式。系统调用按照功能分为进程管理、文件操作、设备管理等，本题描述的是文件操作系统调用相关的执行。
\item 单处理器系统中，可并行执行或工作的对象是（D ）\\
1)进程与进程\\
2)处理器与设备\\
3)处理器与通道\\
4)设备与设备\\
\begin{enumerate}[A]
	\item 1 2 3
	\item 1 2 4
	\item 1 3 4
	\item 2 3 4
\end{enumerate}
并行指同一时刻同时发生，同一时刻单个处理器只能运行一个进程。
\item 下列选项中，操作系统提供给应用程序的接口是（A ）
\begin{enumerate}[A]
	\item 系统调用
	\item 中断
	\item 库函数
	\item 原语
\end{enumerate}

\item 下列选项中，在用户态执行的是（A ）
\begin{enumerate}[A]
	\item 命令解释程序
	\item 缺页处理程序
	\item 进程调度程序
	\item 时钟中断处理程序
\end{enumerate}
后3个选项都属于内核的功能，在内核态。命令解释程序则属于应用程序。
\item 计算机开机后，操作系统最终被加载到（ D）
\begin{enumerate}[A]
	\item BIOS
	\item ROM
	\item EPROM
	\item RAM
\end{enumerate}
\item 操作系统属于B
\begin{enumerate}[A]
	\item 硬件
	\item 系统软件
	\item 通用库
	\item 应用软件
\end{enumerate}
操作系统是管理计算机硬件与软件资源的计算机程序，例如Windows，Linux，Android，iOS等。应用软件一般是基于操作系统提供的接口，为针对使用者的某种应用目的所撰写的软件，例如Office Word，浏览器，手机游戏等。而通用库，一般是指为了便于程序开发，对常用的程序功能封装后被调用的程序。\\
以ucore OS为例，它通过I/O子系统和各种驱动程序直接控制时钟，串口，显示器等计算机硬件外设，并通过系统调用接口给在其上运行的应用软件提供服务，并通过进程管理子系统、CPU调度器、内存管理子系统、文件子系统、I/O子系统来管理应用软件的运行和实现具体的服务。
\item 以下哪个不能用于描述操作系统D
\begin{enumerate}[A]
	\item 
	使计算机方便使用
	\item 可以管理计算机硬件
	\item 可以控制应用软件的执行
	\item 负责生成应用软件 
\end{enumerate}
解释：操作系统负责管理计算机的硬件资源，使得用户不需要关心硬件的工作过程，极大地方便了计算机的使用。我们日常使用计算机，往往已经在使用了特定的操作系统，例如Windows，而在操作系统上，会同时运行多个应用软件，例如浏览器，音乐播放器等，为了让一个或者多个软件能够正常使用有限的硬件资源，操作系统需要管理应用程序的执行过程。一般来说，像浏览器，音乐播放器，和其他应用软件，都是由特定的个人和团队开发的，操作系统不负责生成应用软件。 以ucore OS开发为例，有了ucore OS，应用软件访问硬件跟简单了，有统一的文件访问方式来访问磁盘或各种外设。ucore OS 可以通过I/O操作控制硬件和应用软件的运行等。但编写软件是程序员的工作，把基于C语言或汇编语言的程序转换并生成执行代码是编译器（如gcc,gas）、连接器(如link)的工作。操作系统可加载运行应用软件的执行代码。
\item 以下不属于操作系统的功能是C
\begin{enumerate}[A]
	\item 
	进程调度
	\item 内存管理
	\item 视频编辑
	\item 设备驱动
\end{enumerate}
视频编辑是一个特定的功能，不是系统范围内的共性需求，具体完成这个功能的是视频编辑应用软件。当然，视频编辑应用软件在涉及文件访问时，是需要操作系统中的文件子系统支持；在涉及视频显示方面，需要操作系统的显卡/GPU等设备驱动支持。
\item 操作系统中的多道程序设计方式用于提高B
\begin{enumerate}[A]
	\item 
	稳定性
	\item 
	效率 
	\item 
	兼容性
	\item 
	可靠性
\end{enumerate}
解释：是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序（早期的操作系统）控制之下，相互穿插的运行。两个或两个以上程序在计算机系统中同处于开始到结束之间的状态。这样可以使得几道独立的程序可以并发地共同使用各项硬件资源，提高了资源的利用率。 以ucore OS为例，在lab5中支持了用户进程，从而可以在内存中存放多个程序，并以进程的方式被操作系统管理和调度。
\item 下面对于分时操作系统的说法，正确的是（C）
\begin{enumerate}[A]
	\item 
	应用程序执行的先后顺序是完全随机的
	\item 
	应用程序按照启动的时间依次执行
	\item 
	应用程序可以交替执行 
	\item  应用程序等待的时间越长，下一次调度被选中的概率一定越大 
\end{enumerate}
解释：选择3更合适。分时操作系统把多个程序放到内存中，将处理机（CPU）时间按一定的时间间隔（简称时间片）分配给程序运行，这样CPU就可以轮流地切换给各终端用户的交互式程序使用。由于时间片很短，远小于用户的交互响应延迟，用户感觉上好像独占了这个计算机系统。应用程序执行的先后顺序主要是由操作系统的调度算法和应用程序本身的行为特征来确定的。调度算法需要考虑系统的效率、公平性等因素。对于1,2而言，从系统的效率上看不会带来好处；对于4而言，可以照顾到公平性，但“一定”的表述太强了，比如如果调度算法是简单的时间片轮转算法（在后续章节“处理器调度”），则4的要求就不会满足了，且更实际的调度算法其实还需考虑等待的事件等诸多因素。 以ucore OS为例，在lab6中支持实现不同的调度算法。对于分时操作系统而言，体现其特征的一个关键点就是要实现时间片轮转调度算法或多级反馈队列调度算法（在后续章节“处理器调度”）。在ucore OS中，可以比较方便地实现这两种调度算法。
\item Unix操作系统属于(A)
\begin{enumerate}[A]
	\item 
	分时操作系统 
	\item 
	批处理操作系统
	\item 
	实时操作系统
	\item 
	分布式操作系统
\end{enumerate}
解释：选择1更合适。Unix操作系统支持交互式应用程序，属于分时操作系统。比早期的批处理操作系统要强大。且它更多地面向桌面和服务器领域，并没有很强的实时调度和实时处理功能，所以一边不划归为实时系统。它虽然有网络支持（如TCP/IP），但实际上它管理的主要还是单个计算机系统让的硬件和应用软件。 以ucore OS为例，它模仿的是Unix操作系统，实现了对应的分时调度算法（时间片轮转、多级反馈队列），所以也算是分时系统。如果ucore实现了实时进程管理、实时调度算法，并支持在内核中的抢占（preempt in kernel），则可以说它也是一个实时系统了。
\item 批处理的主要缺点是(B)
\begin{enumerate}[A]
	\item 
	效率低
	\item 
	失去了交互性 
	\item 
	失去了并行性
	\item 
	以上都不是
\end{enumerate}
解释：批处理操作系统没有考虑人机交互所需要的分时功能，所以开发人员或操作人员无法及时与计算机进行交互。 以ucore OS为例，如果它实现的调度算法是先来先服务调度算法（在后续章节“处理器调度”，相对其他调度算法，具体实现更简单），那它就是一种批处理操作系统了，没有很好的人机交互能力。
\item 关于操作系统，说法正确的是（ABC）
\begin{enumerate}[A]
	\item  操作系统属于软件
	\item 
	操作系统负责资源管理
	\item 
	操作系统使计算机的使用更加方便
	\item 
	操作系统必须要有用户程序才能正常启动
\end{enumerate}
操作系统是一种软件，特定指是系统软件，其更功能是管理计算机资源，让用户和应用程序更方便高效地使用计算机。 以ucore OS为例，其实没有用户程序，操作系统也可以正常运行。所以选项4是不对的。
\item 设备管理的功能包括（ACD）
\begin{enumerate}[A]
	\item  设备的分配和回收
	\item 
	进程调度
	\item 
	虚拟设备的实现
	\item 
	外围设备启动
\end{enumerate}
进程调度是属于操作系统的进程管理和处理器调度子系统要完成的工作，与设备管理没有直接关系 以ucore OS为例（lab5以后的实验），与进程调度相关的实现位于kern/process和kern/schedule目录下；与设备管理相关的实现主要位于kern/driver目录下
\item 多道批处理系统主要考虑的是(CD)
\begin{enumerate}[A]
	\item 
	交互性
	\item 
	及时性
	\item 
	系统效率
	\item 
	吞吐量
\end{enumerate}
解释：交互性和及时性是分时系统的主要特征。多道批处理系统主要考虑的是系统效率和系统的吞吐量。 以ucore OS为例（lab6实验）,这主要看你如何设计调度策略了，所以如果实现FCFS(先来想服务)调度算法，这可以更好地为多道批处理系统服务；如果实现时间片轮转（time-slice round robin）调度算法，则可以有比较好的交互性；如果采用多级反馈队列调度算法，则可以兼顾上述4个选项，但交互性用户程序获得CPU的优先级更高。

\end{enumerate}