------------------------------Go语言圣经------------------------------
-------------------------简介-------------------------
  Go是一个开源的编程语言，它很容易用于构建简单、可靠和高效的软件。
  Go语言有着和C语言类似的语法外表，和C语言一样是专业程序员的必备工具，可以用最小的代价获得最大的战果。 但是它不仅仅是一个更新的C语言。它还从其他语言借鉴了很多好的想法，同时避免引入过度的复杂性。 Go语言中和并发编程相关的特性是全新的也是有效的，同时对数据抽象和面向对象编程的支持也很灵活。 Go语言同时还集成了自动垃圾收集技术用于更好地管理内存。
  Go语言尤其适合编写网络服务相关基础设施，同时也适合开发一些工具软件和系统软件。
  Go编写的程序通常比脚本语言运行的更快也更安全，而且很少会发生意外的类型错误。
--------------------Go语言起源--------------------
  Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。
  顺序通信进程 （communicating sequential processes ，缩写为CSP。在CSP中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。
--------------------产生背景--------------------
  “软件的复杂性是乘法级相关的”，通过增加一个部分的复杂性来修复问题通常将慢慢地增加其他部分的复杂性。
  简洁的设计需要在工作开始的时候舍弃不必要的想法，并且在软件的生命周期内严格区别好的改变和坏的改变。通过足够的努力，一个好的改变可以在不破坏原有完整概念的前提下保持自适应，正如Fred Brooks所说的“概念完整性”；而一个坏的改变则不能达到这个效果，它们仅仅是通过肤浅的和简单的妥协来破坏原有设计的一致性。只有通过简洁的设计，才能让一个系统保持稳定、安全和持续的进化。
  Go语言的这些地方都做的还不错：拥有自动垃圾回收、一个包系统、函数作为一等公民、词法作用域、系统调用接口、只读的UTF8字符串等。但是Go语言本身只有很少的特性，也不太可能添加太多的特性。例如，它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。
  Go语言有足够的类型系统以避免动态语言中那些粗心的类型错误，但是，Go语言的类型系统相比传统的强类型语言又要简洁很多。Go语言简洁的类型系统给程序员带来了更多的安全性和更好的运行时性能。
------------------------------------------------
--------------------chapter 1 入门--------------------
---------------
1.1 Hello,World
**********
//helloworld.go
package main
import "fmt"
func main(){
  fmt.Println("Hello,World")
}
**********
Go是一门编译型语言，Go语言的工具链将源代码及其依赖转换成计算机的机器指令。
**********
go run helloworld.go
**********
go 命令有一系列子命令，这个命令编译一个或多个以.go结尾的源文件、链接库文件，并运行最终生成的可执行文件。
Go语言原生支持Unicode，它可以处理全世界任何语言的文本。
**********
go build helloworld.go
**********
编译程序生成一个名为helloworld的可执行的二进制文件。
1. Go语言的代码通过包（package）组织，包类似于其它语言里的库（libraries）或者模块（modules）。一个包由位于单个目录下的一个或多个.go源代码文件组成, 目录定义包的作用。
2. Go的标准库提供了100多个包，以支持常见功能，如输入、输出、排序以及文本处理。
3. fmt 包，就含有格式化输出、接收输入的函数。
4. Println 是其中一个基础函数，可以打印以空格间隔的一个或多个值，并在最后添加一个换行符，从而输出一整行。
5. main 包比较特殊。它定义了一个独立可执行的程序，而不是一个库。
6. 在main 里的 main 函数也很特殊，它是整个程序执行时的入口。
7. 必须恰当导入需要的包，缺少了必要的包或者导入了不需要的包，程序都无法编译通过。
8. import 声明必须跟在文件的 package 声明之后。
9. 一个函数的声明由 func 关键字、函数名、参数列表、返回值列表（这个例子里的 main 函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成。
10. Go语言不需要在语句或者声明的末尾添加分号，除非一行上有多条语句。实际上，编译器会主动把特定符号后的换行符转换为分号, 因此换行符添加的位置会影响Go代码的正确解析。
11.  gofmt 工具把代码格式化为标准格式，并且 go 工具中的 fmt 子命令会对指定包, 否则默认为当前目录, 中所有.go源文件应用 gofmt 命令。
---------------
1.2 命令行参数
A. 命令行参数
  1. os 包以跨平台的方式，提供了一些与操作系统交互的函数和变量；
  2. os.Args变量是一个字符串（string）的切片（slice）；
  3. os.Args的第一个元素，os.Args[0], 是命令本身的名字；其它的元素则是程序启动时传给它的参数。
  4. os.Args[1:len(os.Args)]简写成os.Args[1:]。
********************
package main

import (
	"fmt"
	"os"
)

func main() {
	var s, sep string
	for i := 1; i < len(os.Args); i++ {
		s += sep + os.Args[i]
		sep = " "
	}
	fmt.Println(s)
}
********************
  5. 注释语句以 // 开头。
  6. 变量会在声明时直接初始化。如果变量没有显式初始化，则被隐式地赋予其类型的零值（zero value），数值类型是0，字符串类型是空字符串""。
  7. 自增语句 i++ 给 i 加1；这和 i += 1 以及 i = i + 1 都是等价的。j = i++ 非法，而且++和--都只能放在变量名后面，因此 --i 也非法。
  8. Go语言只有for循环这一种循环语句。for循环有多种形式：
  **********
  for initialization; condition; post {
    // zero or more statements
  }
  **********
  9. for循环三个部分不需括号包围。大括号强制要求, 左大括号必须和post语句在同一行。
  10. initialization语句是可选的，在循环开始前执行。initalization如果存在，必须是一条简单语句（simple statement），即，短变量声明、自增语句、赋值语句或函数调用。 condition 是一个布尔表达式（boolean expression），其值在每次循环迭代开始时计算。如果为 true 则执行循环体语句。 post 语句在循环体执行结束后执行，之后再次对 condition 求值。 condition 值为 false 时，循环结束。
  11. for循环的这三个部分每个都可以省略，如果省略 initialization 和 post ，分号也可以省略。
  12. for 循环的另一种形式, 在某种数据类型的区间（range）上遍历。
********************
package main

import (
	"fmt"
	"os"
)

func main() {
	s, sep := "", ""
	for _, arg := range os.Args[1:] {
		s += sep + arg
		sep = " "
	}
	fmt.Println(s)
}
********************
  13. 每次循环迭代，range 产生一对值；索引以及在该索引处的元素值。这个例子不需要索引，但 range 的语法要求, 要处理元素, 必须处理索引。Go语言不允许使用无用的局部变量（local variables），因为这会导致编译错误。
  14. Go语言中这种情况的解决方法是用 空标识符 （blank identifier），即 _ （也就是下划线）。空标识符可用于任何语法需要变量名但程序逻辑不需要的时候。
  15.声明变量：
    s := ""
    var s string
    var s = ""
    var s string = ""
    第一种形式，是一条短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。
    第二种形式依赖于字符串的默认初始化零值机制，被初始化为""。
    第三种形式用得很少，除非同时声明多个变量。
    第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。
  16. += 连接原字符串，如果连接涉及的数据量很大，这种方式代价高昂。简单且高效的解决方案：
    **********
    fmt.Println(strings.Join(os.Args[1:], " "))
    **********
--------------------
1.3 查找重复的行
打印重复的行
********************

********************
  1. map存储了键/值（key/value）的集合，对集合元素，提供常数时间的存、取或测试操作。键可以是任意类型，只要其值能用 == 运算符比较，最常见的例子是字符串；值则可以是任意类型。
  2. 内置函数 make 创建空 map 。
  3. map 的迭代顺序并不确定，从实践来看，该顺序随机，每次运行都会变化。
------------------------------
  Why：映射的“顺序”取决于所使用的哈希函数。 哈希函数被随机化，以防止使用哈希冲突的拒绝服务攻击。
------------------------------
  4. Scanner读取输入并将其拆成行或单词；通常是处理行形式的输入最简单的方法。
  5. Printf转换
    %d		十进制整数
    %x, %o, %b	十六进制，八进制，二进制整数
    %f, %g, %e	浮点数：3.141593 3.141592653589793 3.141593e+00
    %t	    	布尔：true或false
    %c		字符（rune）（Unicode码点）
    %s		字符串
    %q		带双引号的字符串"abc"或带单引号的字符'c'
    %v		变量的自然形式（natural format）
    %T		变量的类型
    %%		字面上的百分号标志（无操作数）
    以字母 f 结尾的格式化函数，如 log.Printf 和 fmt.Errorf
********************
// dup
package main

import (
	"bufio"
	"fmt"
	"os"
)

func main() {
	counts := make(map[string]int)
	files := os.Args[1:]
	if len(files) == 0 {
		countLines(os.Stdin, counts)
	} else {
		for _, arg := range files {
			f, err := os.Open(arg)
			if err != nil {
				fmt.Fprintf(os.Stderr, "dup2: %v\n", err)
				continue
			}
			countLines(f, counts)
			f.Close()
		}
	}
	for line, n := range counts {
		if n > 1 {
			fmt.Printf("%d\t%s\n", n, line)
		}
	}
}

func countLines(f *os.File, counts map[string]int) {
	input := bufio.NewScanner(f)
	for input.Scan() {
		counts[input.Text()]++
	}
}
********************
  6. os.Open 函数返回两个值。第一个值是被打开的文件( *os.File ），其后被 Scanner 读取。返回的第二个值是内置 error 类型的值。如果 err 等于内置值 nil，那么文件被成功打开。
  7. map 是一个由 make 函数创建的数据结构的引用。 map 作为为参数传递给某函数时，该函数接收这个引用的一份拷贝。被调用函数对 map 底层数据结构的任何修改，调用者函数都可以通过持有的 map 引用看到。
********************
// dup
package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"strings"
)

func main() {
	counts := make(map[string]int)
	for _, filename := range os.Args[1:] {
		data, err := ioutil.ReadFile(filename)
		if err != nil {
			fmt.Fprintf(os.Stderr, "dup3: %v\n", err)
		}
		for _, line := range strings.Split(string(data), "\n") {
			counts[line]++
		}
	}
	for line, n := range counts {
		if n > 1 {
			fmt.Printf("%d\t%s\n", n, line)
		}
	}
}
********************
  8. ReadFile 函数返回一个字节切片（byte slice），必须把它转换为 string ，才能用 strings.Split 分割。
  9. bufio.Scanner 、 ioutil.ReadFile 和 ioutil.WriteFile 都使用 *os.File 的 Read 和 Write 方法
--------------------
1.4 GIF动画
********************
package main

import (
	"image"
	"image/color"
	"image/gif"
	"io"
	"math"
	"math/rand"
	"os"
	"time"
)

var palette = []color.Color{color.White, color.Black}

const (
	whiteIndex = 0
	blackIndex = 1
)

func main() {
	rand.Seed(time.Now().UTC().UnixNano())
	lissajous(os.Stdout)
}

func lissajous(out io.Writer) {
	const (
		cycles  = 5
		res     = 0.001
		size    = 100
		nframes = 64
		delay   = 8
	)
	freq := rand.Float64() * 3.0
	anim := gif.GIF{LoopCount: nframes}
	phase := 0.0
	for i := 0; i < nframes; i++ {
		rect := image.Rect(0, 0, 2*size+1, 2*size+1)
		img := image.NewPaletted(rect, palette)
		for t := 0.0; t < cycles*2*math.Pi; t += res {
			x := math.Sin(t)
			y := math.Sin(t*freq + phase)
			img.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex)
		}
		phase += 0.1
		anim.Delay = append(anim.Delay, delay)
		anim.Image = append(anim.Image, img)
	}
	gif.EncodeAll(out, &anim)
}
********************
--------------------
1.5 获取URL
********************
// fetch
package main

import (
	"fmt"
	"io/ioutil"
	"net/http"
	"os"
)

func main() {
	for _, url := range os.Args[1:] {
		resp, err := http.Get(url)
		if err != nil {
			fmt.Fprintf(os.Stderr, "fetch: %v\n", err)
			os.Exit(1)
		}
		b, err := ioutil.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err)
			os.Exit(1)
		}
		fmt.Printf("%s", b)
	}
}
********************
  1. 函数调用io.Copy(dst, src)会从src中读取内容，并将读到的结果写入到dst中，这个函数替代掉例子中的ioutil.ReadAll来拷贝响应结构体到os.Stdout，避免申请一个缓冲区（例子中的b）来存储。
  ***************
  _, err = io.Copy(os.Stdout, resp.Body)
  if err != nil {
  fmt.Fprintf(os.Stderr, "fetch: reading %s: %v\n", url, err)
    os.Exit(1)
  }
  resp.Body.Close()
  ***************
  2. strings.HasPrefix判断前缀；
  3. 可以从resp.Status变量得到该状态码。
--------------------
1.6 并发获取多个URL
********************
// fetchall
package main

import (
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"time"
)

func main() {
	start := time.Now()
	ch := make(chan string)
	for _, url := range os.Args[1:] {
		go fetch(url, ch)
	}
	for range os.Args[1:] {
		fmt.Println(<-ch)
	}
	fmt.Printf("%.2fs elapsed\n", time.Since(start).Seconds())
}

func fetch(url string, ch chan<- string) {
	start := time.Now()
	resp, err := http.Get(url)
	if err != nil {
		ch <- fmt.Sprint(err)
		return
	}
	nbytes, err := io.Copy(ioutil.Discard, resp.Body)
	resp.Body.Close()
	if err != nil {
		ch <- fmt.Sprintf("while reading %s: %v", url, err)
		return
	}
	secs := time.Since(start).Seconds()
	ch <- fmt.Sprintf("%.2fs %7d %s", secs, nbytes, url)
}
********************
  1. goroutine是一种函数的并发执行方式，而channel是用来在goroutine之间进行参数传递。
  2. go function则表示创建一个新的goroutine，并在这个新的goroutine中执行这个函数。
  3. io.Copy会把响应的Body内容拷贝到ioutil.Discard输出流中，这个变量看作一个垃圾桶，每当请求返回内容时，fetch函数都会往ch这个channel里写入一个字符串，由main函数里的第二个for循环来处理并打印channel里的这个字符串。
  4. 每一个fetch函数在执行时都会往channel里发送一个值(ch <- expression)，主函数负责接收这些值(<-ch)。这个程序中我们用main函数来接收所有fetch函数传回的字符串，可以避免在goroutine异步执行还没有完成时main函数提前退出。
--------------------
1.7 Web服务
********************
// server1
package main

import (
	"fmt"
	"log"
	"net/http"
)

func main() {
	http.HandleFunc("/", handler)
	log.Fatal(http.ListenAndServe("localhost:8000", nil))
}

func handler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
}
********************
添加访问次数
// server1
package main

import (
	"fmt"
	"log"
	"net/http"
	"sync"
)

var mu sync.Mutex
var count int

func main() {
	http.HandleFunc("/", handler)
	http.HandleFunc("/count", counter)
	log.Fatal(http.ListenAndServe("localhost:8000", nil))
}

func handler(w http.ResponseWriter, r *http.Request) {
	mu.Lock()
	count++
	mu.Unlock()
	fmt.Fprintf(w, "URL.Path = %q\n", r.URL.Path)
}

func counter(w http.ResponseWriter, r *http.Request) {
	mu.Lock()
	fmt.Fprintf(w, "Count %d\n", count)
	mu.Unlock()
}
********************
  1. 代码里的mu.Lock()和mu.Unlock()调用将修改count的所有行为包在中间的目的。
********************
func handler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintf(w, "%s %s\n", r.Method, r.URL, r.Proto)
	for k, v := range r.Header {
		fmt.Fprintf(w, "Head[%q]\n", k, v)
	}
	fmt.Fprintf(w, "Host = %q\n", r.Host)
	fmt.Fprintf(w, "RemoteAddr = %q\n", r.RemoteAddr)
	if err := r.ParseForm(); err != nil {
		log.Print(err)
	}
	for k, v := range r.Form {
		fmt.Fprintf(w, "Form[%q] = %q\n", k, v)
	}
}
********************
  2. 用if和ParseForm结合可以让代码更加简单，并且可以限制err这个变量的作用域。
  3. 字符串转换为数字可以调用strconv.Atoi函数。
--------------------
1.8 本章要点
  1. switch结构：
  ***************
  switch coinflip() {
  case "heads":
    heads++
  case "tails":
    tails++
  default:
    fmt.Println("landed on edge!")
  }
  ***************
  2. Go语言里的switch还可以不带操作对象，可以直接罗列多种条件：
  ***************
  switch {
  case x > 0:
    return +1
  default:
    return 0
  case x < 0:
    return -1
  }
  ***************
  3. 命名类型： 类型声明使得我们可以很方便地给一个特殊类型一个名字。
  ***************
  type Point struct {
    X, Y int
  }
  ***************
  4. 指针： Go语言提供了指针。指针是一种直接存储了变量的内存地址的数据类型。
    在其它语言中，比如C语言，指针操作是完全不受约束的。在另外一些语言中，指针一般被处理为“引用”，除了到处传递这些指针之外，并不能对这些指针做太多事情。Go语言在这两种范围中取了一种平衡。指针是可见的内存地址，&操作符可以返回一个变量的内存地址，并且*操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作
  5. 方法和接口： 方法是和命名类型关联的一类函数。
  6. 包（packages）： Go语言提供了一些很好用的package，并且这些package是可以扩展的。
  7. 注释：在源文件的开头写的注释是这个源文件的文档。
-------------------------chapter 2 程序结构-------------------------
--------------------
2.1 命名
  命名规则：一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。
  关键字：
  break		default		func	interface	select
  case		defer		go	map		struct
  chan		else		goto	package		switch
  const		fallthrough	if	range		type
  continue	for		import	return		var
  预定义名字：
  内建常量：
    true false iota nil
  内建类型：
    int int8 int16 int32 int64
    uint uint8 uint16 uint32 uint64 uintptr
    float32 float64 complex128 complex64
    bool byte rune string error
  内建函数：
    make len cap new append copy close delete
    complex real imag
    panic recover
  这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们。
  1. 如果一个名字是在函数内部定义，那么它的就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。
  2. 名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的，那么它将是导出的，也就是说可以被外部的包访问，包本身的名字一般总是用小写字母。
  3. 名字的长度没有逻辑限制。
--------------------
2.2 声明
  1. 声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明。
  2. 每个源文件以包的声明语句开始，说明该源文件是属于哪个包。包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要。
  3. 一个函数的声明由一个函数名字、参数列表、一个可选的返回值列表和包含函数定义的函数体组成。如果函数没有返回值，那么返回值列表是省略的。执行函数从函数的第一个语句开始，依次顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。
  4. func fToC(f float64) float64{}
--------------------
2.3 变量
  var 变量名字 类型 = 表达式
  1. 其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。
  2. 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。
  3. 在Go语言中不存在未初始化的变量。
  4. 可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量：
  **********
  var i, j, k int
  var b, f, s = true, 2.3, "four"
  **********
  5. 一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化:
  **********
  var f, err = os.Open(name)
  **********
  A. 简短变量声明
  可用于声明和初始化局部变量，“名字:= 表达式”形式声明变量，变量的类型根据表达式来自动推导
  简短变量声明语句也可以用来声明和初始化一组变量：
  i, j := 0, 1
  简短变量声明语句也可以用函数的返回值来声明和初始化变量。
  **********
  f, err := os.Open(name)
  if err != nil {
    return err
  }
  f.Close()
  **********
  简短变量声明左边的变量可能并不是全部都是刚刚声明的，如果有一些已经在相同的词法域声明过了，对这些已经声明过的变量就只有赋值行为了。
  简短变量声明语句中必须至少要声明一个新的变量。
  简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价，如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量。
  B. 指针
  一个指针的值是另一个变量的地址。一个指针对应变量在内存中的存储位置。
  并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。
  通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字
  用法和C相似
  变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受 & 取地址操作。
  任何类型的指针的零值都是nil。
  在Go语言中，返回函数中局部变量的地址也是安全的。
  //调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量。每次调用f函数都将返回不同的结果
  ********************
  var p = f()
  func f() *int {
    v := 1
    return &v
  }
  ********************
  如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值。
  每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名。
  垃圾回收时，要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名。
  不仅仅是指针会创建别名，很多其他引用类型也会创建别名，例如slice、map和chan，甚至结构体、数组和接口都会创建所引用变量的别名。
  echo的加入命令行参数
********************
// echo4
package main

import (
	"flag"
	"fmt"
	"strings"
)

var n = flag.Bool("n", false, "omit trailing newline")
var sep = flag.String("s", " ", "separator")

func main() {
	flag.Parse()
	fmt.Print(strings.Join(flag.Args(), *sep))
	if !*n {
		fmt.Println()
	}
}
********************
  flag.Bool会创建一个新的对应布尔型标志参数的变量，三个属性：
    第一个是命令行标志参数"n"
    然后默认值false
    最后标志参数的描述信息
  如果用户输入无效参数或-h或-help，就打印帮助
  flag.String将创建一个对应字符串类型的标志参数变量
  这里都是指向它们的指针
  flag.Parse，用于更新参数对应变量的值，当解析错误，就调用os.Exit(2)
  C. new函数
    new只是一个预定义的函数，调用用内建的new函数，表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为 *T 。
    如果两个类型都是空的，也就是说类型的大小是0，例如 struct{} 和 [0]int , 有可能有相同的地址。
  D. 变量的生命周期
    对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。
    局部变量的声明周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。函数的参数变量和返回值变量都是局部变量。
    for t := 0.0; t < cycles*2*math.Pi; t += res {
      x := 1
      y := 2
    }
    在每次循环的开始会创建临时变量t，然后在每次循环迭代中创建临时变量x和y。
---------------
如何知道一个变量是何时可以被回收？
从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。
因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。
---------------
    编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，并不是由用var还是new声明变量的方式决定的。
    ---------------
    var global *int
    func f() {
      var x int
      x = 1
      global = &x
    }
    func g() {
      y := new(int)
      *y = 1
    }
    ---------------
    f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的,x局部变量从f中逃逸了；
    当g函数返回时，变量 *y 将是不可达的，也就是说可以马上被回收的。编译器可以选择在栈上分配 *y 的存储空间，也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间，不需为了编写正确的代码而要考虑变量的逃逸行为。
    如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收。
--------------------
2.4 赋值
  最简单的赋值语句是将要被赋值的变量放在=的左边
  x = 1				// 命名变量的赋值
  *p = true		   	// 通过指针间接赋值
  person.name = "bob"		// 结构体字段赋值
  count[x] = count[x] * scale 	// 数组、slice或map的元素赋值
  特定的二元算术运算符和赋值语句的复合操作有一个简洁形式:
  count[x] *= scale
  数值变量也可以支持 ++ 递增和 -- 递减语句，自增和自减是语句，而不是表达式，因此 x = i++ 之类的表达式是错误的。
  A. 元组赋值
    在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。
    x, y = y, x
    a[i], a[j] = a[j], a[i]
    但如果表达式太复杂的话，应该尽量避免过度使用元组赋值,可读性会变差。
    当调用一个有多个返回值的函数在元组赋值右边的表达式中时，左边变量的数目必须和右边一致：
      f, err = os.open("foo.txt")
      v, ok = m[key]	//map lookup
      v, ok = x.(T)	//type assertion
      v, ok = <-ch	//channel receive
    和变量声明一样，我们可以用下划线空白标识符 _ 来丢弃不需要的值
      _, err = io.Copy(dst, src) // 丢弃字节数
  B. 可赋值性
    隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为。
    medals := []string{"gold", "silver", "bronze"}
    隐式地对slice的每个元素进行赋值操作:
    medals[0] = "gold"
    medals[1] = "silver"
    medals[2] = "bronze"
    只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。
    赋值规则：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。
    == 或 != 进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。
--------------------
2.5 类型
  变量或表达式的类型定义了对应存储值的属性特征：数值在内存的存储大小，它们在内部是如何表达的，是否支持一些操作符，以及它们自己关联的方法集等。
  在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念，分别在不同情况下代表不同的含义。
  一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。
  ---------------
  type 类型名字 底层类型
  ---------------
  类型声明语句一般出现在包一级。
  目前，对于中文汉字，Unicode标志都作为小写字母处理。
--------------------
// tempconv
package tempconv

// import "fmt"

type Celsius float64
type Fahrenheit float64

const (
	AbsoluteZeroC Celsius = -273.15
	FreezingC     Celsius = 0
	BoilingC      Celsius = 100
)

func CToF(c Celsius) Fahrenheit { return Fahrenheit(c*9/5 + 32) }

func FToC(f Fahrenheit) Celsius { return Celsius((f - 32) * 5 / 9) }
--------------------
  Celsius和Fahrenheit虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算。
  类型转换操作并不是函数调用。
  对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型，如果T是指针类型，可能会需要用小括弧包装T，比如 (*int)(0) ，只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身。
  数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换。
  底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。
  比较运算符 == 和 < 也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。但是如果两个值有着不同的类型，则不能直接进行比较。
  命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。
  ---------------
  func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
  //Celsius类型的参数c出现在了函数名的前面，表示声明的是Celsius类型的一个叫名叫String的方法，该方法返回该类型对象c带着°C温度单位的字符串
  ---------------
  许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对应的String方法返回的结果打印。
--------------------
2.6 包和文件
  支持模块化、封装、单独编译和代码重用。
  一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径。
  包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。如果一个名字是大写字母开头的，那么该名字是导出的。
  每个源文件都是以包的声明语句开始，用来指明包的名字。
  包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释
--------------------
2.6.1 导入包
  每个包都是有一个全局唯一的导入路径，导入语句中类似"gopl.io/ch2/tempconv"的字符串对应包的导入路径。Go语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。
  如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理。
********************
// cf
package main

import (
	"fmt"
	"os"
	"strconv"

	"../tempconv"
)

func main() {
	for _, arg := range os.Args[1:] {
		t, err := strconv.ParseFloat(arg, 64)
		if err != nil {
			fmt.Fprintf(os.Stderr, "cf: %v\n", err)
			os.Exit(1)
		}
		f := tempconv.Fahrenheit(t)
		c := tempconv.Celsius(t)
		fmt.Printf("%s = %s, %s = %s\n",
			f, tempconv.FToC(f), c, tempconv.CToF(c))
	}
}
********************
--------------------
2.6.2 包的初始化
  1. 包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：
  ***************
  var a = b + c		//a第三个初始化
  var b = f() 		//b第二个初始化
  var c = 1		//c第一个初始化
  func f() int { return c + 1 }
  ***************
  如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。
  2. 在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数,init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。
  ***************
  func init() { /*...*/ }
  ***************
  在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。
  3. 每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。
********************
// popcount
package popcount

import "fmt"

var pc [256]byte

func init() {
	for i := range pc {
		pc[i] = pc[i/2] + byte(i&1)
	}
}

func PopCount(x uint64) int {
	return int(pc[byte(x>>(0*8))] +
		pc[byte(x>>(1*8))] +
		pc[byte(x>>(2*8))] +
		pc[byte(x>>(3*8))] +
		pc[byte(x>>(4*8))] +
		pc[byte(x>>(5*8))] +
		pc[byte(x>>(6*8))] +
		pc[byte(x>>(7*8))])
}
********************
  将初始化逻辑包装为一个匿名函数处理：
********************
var pc [256]byte = func() (pc [256]byte) {
	for i := range pc {
		pc[i] = pc[i/2] + byte(i&1)
	}
	return
}()
********************
  //循环省略了值部分，因此可以：
  for i, _ := range pc{}
  重写PopCount函数，用一个循环代替单一的表达式:
********************
func PopCount_Cycle(x uint64) int {
	n := 0
	for i := 0; i < 8; i++ {
		n += int(pc[byte(x>>(i*8))])
	}
	return n
}
********************
  用移位算法重写PopCount函数，每次测试最右边的1bit，然后统计总数。
********************
func PopCount2(x uint64) int {
	num := 0
	for i := 0; x != 0 && i < 64; i, x =  i + 1， x >> 1{
		if x&1 == 1 {
			num++
		}
	}
	return num
}
********************
  表达式 x&(x-1) 用于将x的最低的一个非零的bit位清零。
********************
func PopCount_Clear(x uint64) int {
	n := 0
	for x != 0 {
		x = x & (x - 1)
		n++
	}
	return n
}
********************
--------------------
2.7 作用域
  1. 声明语句的作用域是指源代码中可以有效使用这个名字的范围。
  2. 不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。
  3. 句法块是由花括弧所包含的一系列语句，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为词法块。对全局的源代码来说，存在一个整体的词法块，称为全局词法块；对于每个包；每个for、if和switch语句，也都对应词法块；每个switch或select的分支也有独立的语法块；当然也包括显式书写的词法块（花括弧包含的语句）。
  4. 对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。
  5. 任何在在函数外部声明的名字可以在同一个包的任何源文件中访问的。
  6. 对于导入的包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。
  7. 控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。
  8. 一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系。
  9. 内部优先于外部变量声明，如果都没有找到，编译报错。
  10. for语句创建了两个词法域：花括弧包含的是显式的部分是for的循环体部分词法域，另外一个隐式的部分则是循环的初始化部分；if和switch语句也会在条件部分创建隐式词法域。
---------------
if x := f(); x == 0 {
  //
} else if y := f(x); x == y {
}
---------------
  11. 如果一个变量或常量递归引用了自身，则会产生编译错误。
  12. 要特别注意短变量声明语句的作用域范围：
********************
var cwd string

func init() {
	cwd, err := os.Getwd()
	if err != nil {
		log.Fatalf("os.Getwd failed: %v", err)
	}
}
********************
    获取当前工作目录，log.Fatalf用于打印日志信息。
    := 语句还是将cwd和err重新声明为新的局部变量，内部声明的cwd将屏蔽外部的声明，不会更新cwd。
    编译器会报错，但是增加一个局部cwd打印语句，检测失效，不报错：
    --------------------
    //init()
    log.Printf("Working directory = %s", cwd)
    --------------------
    解决办法：单独声明err变量。
    --------------------
    var err error
    cwd, err = os.Getwd()
    --------------------
--------------------chapter 3 基础数据类型--------------------
  数据类型分为四类：基础类型、复合类型、引用类型和接口类型。
  基础类型：数字、字符串、布尔型；
  复合类型：数组、结构体；
  引用类型：指针、切片、字典、函数、通道；
--------------------
3.1 整型
  有符号整数类型	无符号整型	大小
  int8		uint8		8
  int16		uint16		16
  int32		uint32		32
  int64		uint64		64
  一般对应特定CPU平台机器字大小的有符号和无符号整数int和uint。因为不同的编译器即使在相同的硬件平台上可能产生不同的大小，为32bit或者64bit。
  1. Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点，可以互换。
  2. byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。
  3. 无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。uintptr类型只有在底层编程时才需要。
  4. int、uint和uintptr是不同类型的兄弟类型。其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作。
  5. 算术运算、逻辑运算和比较运算的二元运算符优先级递减：
  * / % << >> & &^
  + - | ^
  == != < <= > >=
  &&
  ||
  取模运算符%仅用于整数间的运算，%取模运算符的符号和被取模数的符号总是一致的：
  -5%3和-5%-3都是-2。
  整数除法会向着0方向截断余数。算术运算超出的高位的bit位部分将被丢弃。
  6. 比较符号：
    == != < <= > >=
    整数、浮点数和字符串可以根据比较结果排序。
  7. 一元的加法和减法运算符：
    对于整数，+x是0+x的简写，-x则是0-x的简写；对于浮点数和复数，+x就是x，-x则是x 的负数。
  8. bit位运算符
    &	位运算AND
    |	位运算OR
    ^	位运算XOR
    &^	位清空（AND NOT）
    <<	左移
    >>	右移
********************
	var x uint8 = 1<<1 | 1<<5
	var y uint8 = 1<<1 | 1<<2
	fmt.Printf("%08b\n", x)
	fmt.Printf("%08b\n", y)
	fmt.Printf("%08b\n", x&y)
	fmt.Printf("%08b\n", x|y)
	fmt.Printf("%08b\n", x^y)
	fmt.Printf("%08b\n", x&^y)
	for i := uint(0); i < 8; i++ {
		if x&(1<<i) != 0 {
			fmt.Println(i)
		}
	}
	fmt.Printf("%08b\n", x<<1)
	fmt.Printf("%08b\n", x>>1)
********************
  %08b中08表示打印至少8个字符宽度，不足的前缀部分用0填充。
  9. 有符号数的右移运算会用符号位的值填充左边空缺的bit位，无符号数的右移运算也是用0填充左边空缺的bit位。
  10. 无符号数往往只有在位运算或像bit集合、分析二进制文件格式或者是哈希和加密操作等。
  算术和逻辑运算的二元操作中必须是相同的类型：
  ********************
  //编译错误
  var a int32 = 1
  var b int32 = 2
  var c int = a + b
  ********************
  可以显示转换类型。
  11. 许多整数之间的相互转换并不会改变数值；它们只是告诉编译器如何解释这个值，对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，可能会改变数值或丢失精度。
  12 %d、%o或%x控制进制格式：
  ********************
  o := 0666
  //438 666 0666
  fmt.Printf("%d %[1]o %#[1]o\n", o)
  x := int64(0xdeadbeef)
  fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x)
  //3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
  ********************
  %之后的 [1] 副词告诉Printf函数再次使用第一个操作数。第二，%后的 # 副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。
  13. 字符面值通过一对单引号直接包含对应字符，字符使用 %c 参数打印，或者是用 %q 参数打印带单引号的字符：
  ********************
  ascii := 'a'
  unicode := '国'
  fmt.Printf("%d %[1]c %[1]q\n", ascii) // "97 a 'a'"
  fmt.Printf("%d %[1]c %[1]q\n", unicode) // "22269 国 '国'"
  fmt.Printf("%d %[1]q\n", newline) // "10 '\n'"
  ********************
--------------------
3.2 浮点数
 两种精度浮点数：float32和float64，由IEEE754浮点数国际标准定义。
 1. 常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38；
 2. 对应的math.MaxFloat64常量大约是1.8e308。对应的math.MaxFloat64常量大约是1.8e308。它们分别能表示的最小值近似为1.4e-45和4.9e-324。
 3. float32提供大约6个十进制的精度，float64提供约15个十进制数的精度。
 4. float32的有效bit位只有23个：
 ********************
 var f float32 = 16777216 // 1 << 24
 fmt.Println(f == f+1) // "true"!
 ********************
 很小或很大可以用科学技术法表示e或E
 5. %g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。
 6. math包提供了IEEE754浮点数标准中定义的特殊值的创建和测试：正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果；NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1)。
 ********************
 var z float64
 fmt.Println(z, -z, 1/z, -1/z, z/z) // "0 -0 +Inf -Inf NaN"
 ********************
 7. math.IsNaN用于测试一个数是否是非数NaN，NaN、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示。
--------------------
3.3 复数
  1. complex64和complex128，分别对应float32和float64两种浮点数精度。
  2. 内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部
  3. 如果一个浮点数面值或一个十进制整数面值后面跟着一个i，构成虚部
  4. 一个复数常量可以加到另一个普通数值常量，也可以用==和!=进行相等比较。
  5. math/cmplx包提供了复数处理的许多函数。
--------------------
3.4 布尔型
  1. true和false，短路行为：如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值，下面是安全的：
  s != "" && s[0] == 'x'
  2. && 的优先级比 || 高。
  3. 布尔值并不会隐式转换为数字值0或1。
--------------------
3.5 字符串
  1. 一个字符串是一个不可改变的字节序列，可以包含任意的数据，包括byte值0，文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列。
  2. len函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i< len(s)条件约束：
  3. 第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节。
  4. 子字符串操作s[i:j]生成一个新字符串，+操作符将两个字符串链接构造一个新字符串。
  5. 字符串可以用==和<进行比较；比较通过逐个字节比较完成的。
  6. 字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值。
  7. 字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的：
  s[0]='L'会被禁止。
  8. 不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存。
---------------
3.5.1 字符串赋值
  1. 文本字符串也以UTF8编码的方式处理，将Unicode码点也写到字符串面值中。
  2. 一个十六进制的转义形式是 \xhh ，其中两个h表示十六进制数字（大写或小写都可以）。一个八进制转义形式是 \ooo ，包含三个八进制的o数字（0到7），但是不能超过 \377 （译注：对应一个字节的范围，十进制为255）。
  3. 原生的字符串使用反引号代替双引号，里面退格、换行都是处理，但是特殊的是删除回车保证所有平台一致。
---------------
3.5.2 Unicode
  1. Unicode码点对应Go语言中的rune整数类型（int32等价类型）。
  2. 将一个符文序列表示为一个int32序列，这种编码方式叫UTF-32或UCS-4，每个
Unicode码点都使用同样的大小32bit来表示，浪费很多存储空间。
---------------
3.5.3 UTF-8
  1. UTF8是一个将Unicode码点编码为字节序列的变长编码，使用1到4个字节来表示每个Unicode码点，ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表示。每个符号编码后第一个字节的高端bit位用于表示总共有多少编码个字节。
  2. 第一个字节的高端bit为0，则表示对应7bit的ASCII字符；
  3. 如果第一个字节的高端bit是110，则说明需要2个字节。
  4. 优点：UTF8编码比较紧凑，完全兼容ASCII码，并且可以自动同步：它可以通过向前回朔最多2个字节就能确定当前字符编码的开始字节的位置。
  5. 它也是一个前缀编码，所以当从左向右解码时不会有任何歧义也并不需要向前查看，但是不知道起点就会发生歧义。
  6. Unicode转义字符 \uhhhh 对应16bit的码点值， \Uhhhhhhhh 对应32bit的码点值，其中h是一个十六进制数字；
  ***************
  "世界"
  "\xe4\xb8\x96\xe7\x95\x8c"
  "\u4e16\u754c"
  "\U00004e16\U0000754c"
  ***************
  7. 不用解码直接测试一个字符串是否是另一个字符串的前缀：
  ***************
  func HasPrefix(s, prefix string) bool {
    return len(s) >= len(prefix) && s[:len(prefix)] == prefix
  }
  //后缀
  func HasSuffix(s, suffix string) bool {
       return len(s) >= len(suffix) && s[len(s)-len(suffix):] == suffix
  }
  //子串
  func Contains(s, substr string) bool {
    for i := 0; i < len(s); i++ {
      if HasPrefix(s[i:], substr) {
        return true
      }
    }
    return false
  }
  ***************
  处理unicode
  ***************
  import "unicode/utf8"
  s := "Hello, 世界"
  fmt.Println(len(s)) // "13"
  fmt.Println(utf8.RuneCountInString(s)) // "9"
  ***************
  为了处理这些真实的字符，我们需要一个UTF8解码器。
  ***************
  for i := 0; i < len(s); {
    r, size := utf8.DecodeRuneInString(s[i:])
    fmt.Printf("%d\t%c\n", i, r)
    i += size
  }
  ***************
  DecodeRuneInString函数都返回一个r和长度，r对应字符本身，长度对应r采用UTF8编码后的编码字节数目。
  Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串。
  ***************
  for i, r := range "Hello, 世界" {
    fmt.Printf("%d\t%q\t%d\n", i, r, r)
  }
  //统计字符数目
  n := 0
  for _, _ = range s {
    n++
  }
  或
  for range s {
    n++
  }
  或
  utf8.RuneCountInString(s)
  ***************
  如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符 \uFFFD ，在印刷中这个符号通常是一个黑色六角或钻石形状。
  8. []rune类型转换应用到UTF8编码的字符串：
  ***************
  s := "プログラム"
  fmt.Printf("% x\n", s) // "e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0"
  r := []rune(s)
  fmt.Printf("%x\n", r) // "[30d7 30ed 30b0 30e9 30e0]"
  ***************
   % x 参数用于在每个十六进制数字前插入一个空格
  9. 将一个[]rune类型的Unicode字符slice或数组转为string，则对它们进行UTF8编码：
   fmt.Println(string(r)) // "プログラム"
  10. 如果对应码点的字符是无效的，则用 \uFFFD 无效字符作为替换。
---------------
3.5.4 字符串和Byte切片
  字符串处理包：bytes、strings、strconv和unicode包。
  strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。
  bytes针对和字符串有着相同结构的[]byte类型，提供了很多类似功能的函数，字符串只读，逐步构建会导致很多分配和复制，使用bytes.BUffer会有效。
  strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。
  unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等，每个函数有一个单一的rune类型的参数，然后返回一个布尔值。
  basename获取文件名：
--------------------
func basename(s string) {
	for i := len(s) - 1; i >= 0; i-- {
		if s[i] == '/' {
			s = s[i+1:]
			break
		}
	}
	for i := len(s) - 1; i >= 0; i-- {
		if s[i] == '.' {
			s = s[:i]
			break
		}
	}
	return s
}
--------------------
********************
func basename2(s string) {
	slash := strings.LastIndex(s, "/")
	s = s[slash+1:]
	if dot := strings.LastIndex(s, "."); dot >= 0 {
		s = s[:dot]
	}
	return s
}
********************
  在数字中每3个加上','：
********************
func comma(s string) string {
	n := len(s)
	if n <= 3 {
		return s
	}
	return comma(s[:n-2]) + "," + s[n-3:]
}
********************
  一个字符串是包含的只读字节数组，一旦创建，是不可变。
  strings包中的六个函数：
    func Contains(s, substr string) bool
    func Count(s, sep string) int
    func Fields(s string) []string
    func HasPrefix(s, prefix string) bool
    func Index(s, sep string) int
    func Join(a []string, sep string) string
  bytes包中也对应的六个函数与上面相同，只不过参数或返回值换位[]byte。
  bytes.Buffer变量并不需要初始化，用于字节缓存：
********************
func intToString(values []int) string {
	var buf bytes.Buffer
	buf.WriteByte('[')
	for i, v := range values {
		if i > 0 {
			buf.WriteString(", ")
		}
		fmt.Fprintf(&buf, "%d", v)
	}
	buf.WriteByte(']')
	return buf.String()
}
********************
  当向bytes.Buffer添加任意字符的UTF8编码时，最好使用bytes.Buffer的WriteRune方法，但是WriteByte方法对于写入类似'['和']'等ASCII字符则会更加有效。
--------------------
3.5.5 字符串和数字的转换
  将一个整数转为字符串，一种方法是用fmt.Sprintf返回一个格式化的字符串；另一个方法是用strconv.Itoa(“整数到ASCII”)。
--------------------
x := 123
y := fmt.Sprintf("%d", x)
fmt.Println(y, strconv.Itoa(x))
--------------------
  1. FormatInt和FormatUint函数可以用不同的进制来格式化数字
  ***************
  fmt.Println(strconv.FormatInt(int64(x), 2)) // "1111011"
  s := fmt.Sprintf("x=%b", x) // "x=1111011"
  ***************
  2. 如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，或者无符号整数解析ParseUint：
  ***************
  x, err := strconv.Atoi("123") // x is an int
  y, err := strconv.ParseInt("123", 10, 64) // base 10, up to 64 bits，16表示int16，0则表示int
  ***************
  3. fmt.Scanf来解析输入的字符串和数字。
--------------------
3.6 常量
  1. 常量表达式的值在编译期计算，而不是在运行期。
  2. 常量的值不可修改，这样可以防止在运行期被意外或恶意的修改。
  ***************
  const (
    e = 2.71828
    pi = 3.14
  )
  ***************
  3. 所有常量的运算都可以在编译期完成，当操作数是常量时，一些运行时的错误也可以在编译时被发现，整数除零、字符串索引越界、任何导致无效浮点数的操作等。
  4. len、cap、real、imag、complex和unsafe.Sizeof返回常量，在编译期确定。
  5. 如果是批量声明的常量，除了第一个外其它的常量右边的初始化表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的：
  ***************
  const (
    a = 1
    b
    c = 2
    d
    //1 1 2 2
  )
  ***************
  可以带来iota常量生成器语法。
--------------------
3.6.1 iota常量生成器
  1. 常量声明可以使用iota常量生成器初始化，生成一组以相似规则初始化的常量，第一个声明置0，后面加1。
  ***************
  type Weekday int
  const (
	Sunday Weekday = iota
	Monday
	Tuesday
	Wednesday
	Thursday
	Friday
	Saturday
  )
  ***************
  给一个无符号整数的最低5bit的每个bit指定一个名字：
  ***************
  type Flags uint

const (
	FlagUp           Flags = 1 << iota // is up
	FlagBroadcast                      // supports broadcast access capability
	FlagLoopback                       // is a loopback interface
	FlagPointToPoint                   // belongs to a point-to-point link
	FlagMulticast                      // supports multicast access capability
)
  ***************
  这些可以用于测试、设置或清除对应的bit位的值：
  ********************
  func IsUp(v Flags) bool     { return v&FlagUp == FlagUp }
  func TurnDown(v *Flags)     { *v &^= FlagUp }
  func SetBroadcast(v *Flags) { *v |= FlagBroadcast }
  func IsCast(v Flags) bool   { return v&(FlagBroadcast|FlagMulticast) != 0 }
  func main() {
	var v Flags = FlagMulticast | FlagUp
	fmt.Printf("%b %t\n", v, IsUp(v)) // "10001 true"
	TurnDown(&v)
	fmt.Printf("%b %t\n", v, IsUp(v)) // "10000 false"
	SetBroadcast(&v)
	fmt.Printf("%b %t\n", v, IsUp(v))   // "10010 false"
	fmt.Printf("%b %t\n", v, IsCast(v)) // "10010 true"
  }
  ********************
  1024的幂：
  ********************
  const (
	_   = 1 << (10 * iota)
	KiB // 1024
	MiB // 1048576
	GiB // 1073741824
	TiB // 1099511627776 (exceeds 1 << 32)
	PiB // 1125899906842624
	EiB // 1152921504606846976
	ZiB // 1180591620717411303424 (exceeds 1 << 64)
	YiB // 1208925819614629174706176
  )
  ********************
--------------------
3.6.2 无类型常量
  1. Go中许多常量并没有一个明确的基础类型，编译器为这些没有明确的基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。
  2. 六种未明确类型的常量类型：无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。
  3. 通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。
  4. math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方，但是如果被指定为确定类型，在使用其他类型要转换：
  ***************
  const Pi64 float64 = math.Pi
  var x float32 = float32(Pi64)
  var y float64 = Pi64
  var z complex128 = complex128(Pi64)
  ***************
  5. 不同写法，不同类型值：
    0	无类型整数
    0.0	无类型浮点数
    0i	无类型复数
    \u0000 无类型字符
    true和false也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。
  6. 只有常量可以是无类型的。当一个无类型的常量被赋值给一个变量的时候或出现在有明确类型的变量声明的右边，将会被隐式转换为对应的类型。
  ***************
  var f float64 = 3 + 0i // untyped complex -> float64
  f = 2 // untyped integer -> float64
  f = 1e123 // untyped floating-point -> float64
  f = 'a' // untyped rune -> float64
  ***************
  7. 无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。
  ********************
  const (
	deadbeef = 0xdeadbeef        // untyped int with value 3735928559
	a        = uint32(deadbeef)  // uint32 with value 3735928559
	b        = float32(deadbeef) // float32 with value 3735928576 (rounded up)
	c        = float64(deadbeef) // float64 with value 3735928559 (exact)
	d        = int32(deadbeef)   // compile error: constant overflows int32
	e        = float64(1e309)    // compile error: constant overflows float64
	f        = uint(-1)          // compile error: constant underflows uint
)
  ********************
  8. 对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型：
  ---------------
  i := 0 // untyped integer; implicit int(0)
  r := '\000' // untyped rune; implicit rune('\000')
  f := 0.0 // untyped floating-point; implicit float64(0.0)
  c := 0i // untyped complex; implicit complex128(0i)
  ---------------
  9. 无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。
  10. 如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变量指定明确的类型：
  ***************
  var i = int8(0)
  var i int8 = 0
  ***************
--------------------chapter 4 复合数据类型--------------------
