Head First设计模式
----------------------------------------
chapter 01 设计模式
--------------------
1. 模拟鸭子
利用继承会导致很难知道鸭子的所有行为，改变base，会导致所有都改变，解决方法，接口。
2. 接口
将fly()和quack()封装为接口flyable()和quackable()，但是会增加代码量，如果每个会飞会叫都要重写方法，因此，该方法并不适合。
*设计原则：找出可能需要变化的部分，把他独立出来，不要和那些不需变化的混在一起，即把会变化的部分封装起来。
3. 设计鸭子的行为
*设计原则：针对接口编程，而不是针对实现编程（针对超类型编程）。
将fly()接口先实现为两个：会飞、不会飞。
针对超类型编程：变量的声明类型应该是超类型，通常是一个抽象类或者是一个接口，只要具体实现此超类型的类所产生的对象，都可以指定给这个变量。
实现多态：
Animal animal = new Dog();
animal.makeSound();
可以通过setter动态设置行为。
----------------------------------------
chapter 02 观察者模式
--------------------
观测者模式：气象站、WeatherData对象、布告板；
当天气数据更新时，需要更新布告板数据，传统做法是直接在measurementsChanged()写更新方法，但是当删除布告板时，需要修改此方法，较为麻烦。
当数据更新时，主题就会把数据更新到观察者对象。
*观察者模式定义了对象之间一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 是一种一对多的关系。
是一种松耦合的关系，有新类型的观察者出现时，主题的代码不需要修改，因为主题唯一依赖的东西是一个实现，Observer接口的对象列表，所以我们可以随时增加观察者。
改变主题或观察者其中一方，并不会影响另一方。
*设计原则：为了交互对象之间的松耦合设计而努力。
JavaAAPI有内置的观察者模式。java.util包（package）内包含最基本的Observer接口与Observable类。
Observable类追踪所有的观察者，并通知他们。Observable是一个“类”，而不是一个接口。
观察者要如何送出通知：
	先调用setChanged()方法，标记状态已经改变的事实；
	然后调用两种notifyObservers()方法中的一个。
观察者如何接收通知：
	如果你想“推”（push）数据给观察者，你可以把数据当作数据对象传送给notifyObservers(arg)方法。否则，观察者就必须从可观察者对象中“拉”（pull）数据。
	setChanged()方法可以让你在更新观察者时，有更多的弹性，你可以更适当地通知观察者。
java.util.Observable的黑暗面：
	可观察者是一个“类”而不是一个“接口”，更糟的是，它甚至没有实现一个接口。限制了它的使用和复用。
Observable是一个类：
	如果某类想同时具有Observable类和另一个超类的行为，就会陷入两难，限制了Observable的复用潜力，Observable将关键的方法保护起来，除非你继承自Observable，否则你无法创建Observable实例并组合到你自己的对象中来。

********************
总结
OO基础:抽象；
OO原则：
	封装变化
	多用组合，少用继承
	针对接口编程，不针对实现编程
	为交互对象之间的松耦合设计而努力
OO模式：观察者模式：
	在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。
1. 观察者模式定义了对象之间一对多的关系。
2. 主题（也就是可观察者）用一个共同的接口来更新观察者
3. 观察者和可观察者之间用松耦合方式结合（loosecoupl-ing），可观察者不知道观察者的细节，只知道观察者实现了观察者接口。
4. 使用此模式时，你可从被观察者处推（push）或拉（pull）数据（然而，推的方式被认为更“正确”）。
5. 有多个观察者时，不可以依赖特定的通知次序。
6. Java有多种观察者模式的实现，包括了通用的java.util.Observable。
7. 要注意java.util.Observable实现上所带来的一些问题。
8. 如果有必要的话，可以实现自己的Observable，这并不难，不要害怕。
9. Swing大量使用观察者模式，许多GUI框架也是如此。
10. 此模式也被应用在许多地方，例如：JavaBeans、RMI。
----------设计原则----------
1. 找出程序中会变化的方面，然后将其和固定不变的方面相分离；
在观察者模式中，会改变的是主题的状态，以及观察者的数目和类型。用这个模式，你可以改变依赖于主题状态的对象，却不必改变主题。这就叫提前规划！
2. 针对接口编程，不针对实现编程；
主题与观察者都使用接口：观察者利用主题的接口向主题注册，而主题利用观察者接口通知观察者。这样可以让两者之间运作正常，又同时具有松耦合的优点
3. 多用组合，少用继承。
观察者模式利用“组合”将许多观察者组合进主题中。对象之间的这种关系不是通过继承产生的，而是在运行时利用组合的方式而产生的。
---------------------------
----------------------------------------

----------------------------------------
chapter 3装饰者模式
--------------------
**********开放-关闭原则**********
类应该对扩展开放，对修改关闭。
********************************
目标：允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。
遵循开放-关闭原则，通常会引入新的抽象层次，增加代码的复杂度。你需要把注意力集中在设计中最有可能改变的地方，然后应用开放-关闭原则。
解决问题：类数量爆炸、设计死板，以及基类加入的新功能并不适用于所有的子类。
关于装饰者模式：
	装饰者和被装饰对象有相同的超类型；
	你可以用一个或多个装饰者包装一个对象；
	既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它；
	装饰者可以在所委托被装饰者的行为之前与 / 或之后，加上自己的行为，以达到特定的目的；
	对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。
**********装饰者模式**********
装饰者模式 动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
****************************
如果你把代码写成依赖于具体的组件类型，那么装饰者就会导致程序出问题。只有在针对抽象组件类型编程时，才不会因为装饰者而受到影响。但是，如果的确针对特定的具体组件编程，就应该重新思考你的应用架构，以及装饰者是否适合。

java.io，装饰者模式：
	LineNumberInputStream，加上了计算行数的能力；
	BufferedInputStream，利用缓冲输入来改进性能；用一个readLine()方法（用来一次读取一行文本输入数据）来增强接口。
	FileInpuStream，被装饰的“组件”。

		FileStream
		StringStream
InputStream	ByteArrayInputStream
		FilterInputStream：PushbackStream、BufferedInputStream、DataInputStream、LineNumberInputStream。

缺点：利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，可能会造成使用此API程序员的困扰。
----------总结----------
1. 继承属于扩展形式之一，但不见得是达到弹性设计的最佳方式。
2. 在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码。
3. 组合和委托可用于在运行时动态地加上新的行为。
4. 除了继承，装饰者模式也可以让我们扩展行为。
5. 装饰者模式意味着一群装饰者类，这些类用来包装具体组件。
6. 装饰者类反映出被装饰的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）。
7. 装饰者可以在被装饰者的行为前面与 / 或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。
8. 你可以用无数个装饰者包装一个组件。
9. 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。
10. 装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。

----------------------------------------
chapter 4 工厂模式
--------------------
工厂处理创建对象的细节。
把创建对象代码封装，当以后实现改变时，只需要修改这个类即可。
静态工厂：利用静态方法定义工厂，可以不需要使用创建对象的方法实例化对象，但不能通过继承来改变创建方法的行为。
实现接口并与一定表示写一个类，并利用implement关键词来实现java接口，泛指实现某个超类型的某个方法。
工厂方法是抽象的，所以依赖子类来处理对象的创建，工厂方法必须返回一个产品，超类中定义的方法，通常使用到工厂方法的返回值，工厂方法将客户和市级创建具体产品的代码分离开来，可能需要参数，也可能不需要。
**********工厂方法模式**********
通过让子类决定该创建的对象是什么，来达到对象创建过程封装的目的。
或者
定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类中。
******************************
1. 创建者类
   抽象创建者类，定义了一个抽象的工厂方法，让子类实现此方法制造产品；
   创建者通常会包含依赖抽象产品的代码，而这些抽象产品由子类制造，创建者不需要真的知道在制造哪种具体产品；
   能够产生产品的类成为具体创建者。
2. 产品类
   这些是具体的产品。
工厂方法模式能够封装具体类型的实例化，让子类决定实例化的类是哪一个，但并不是允许子类本身在运行时做决定，而是在编写创建者类时，不需要知道实际创建的产品是哪一个。

**********依赖倒置原则**********
要依赖抽象，不要依赖具体类。
******************************
不能让高层组件依赖底层组件，不管高层或底层组件，两者都应该依赖于抽象。
设计依赖倒置：
	变量不可以具有具体类的引用：如果使用new，就会持有具体类的引用，可以改用工厂模式；
	不要让类派生出自具体类：如果派生来自具体类，就会依赖具体类；
	不要覆盖基类中已实现的方法：如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合该继承的抽象，基类中已经实现的方法，应该有所有子类共享。
**********抽象工厂模式**********
提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
******************************
抽象工厂模式允许客户使用抽象的借口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么。
抽象工厂的任务是定义一个负责创建一组产品的接口，接口内每个方法都负责创建一个具体产品，同时利用实现抽象工厂的子类来提供这些具体的做法。

**********工厂和抽象工厂方法**********
1. 工厂使用的是类，通过继承创建对象，创建对象需要扩展一个类，并覆盖它的工厂方法，通过子类来创建对象，客户只需要知道它所使用的抽象类型就可以创建；
而抽象工厂使用的是对象，通过对象的组合实现，通过产品家族的抽象类型，先实例化，传入到抽象类型代码中，新增扩展比较困难。
抽象工厂：需要创建产品家族和想让制造的相关产品集合起来时使用；
工厂方法：目前不知道将来需要实例化哪些具体类，可以通过继承使用。
----------总结----------
1. 所有工厂都是用来封装对象的创建；
2. 简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类中解耦；
3. 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象；
4. 抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中；
5. 所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合；
6. 工厂方法允许类将实例化延迟到子类进行；
7. 抽象工厂创建相关的对象家族，而不需要依赖它们的具体类；
8. 依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象；
9. 工厂是很有威力的技巧，帮助我们针对抽象编程，而不是针对具体类编程。
------------------------
----------------------------------------
chapter 5 单件模式
--------------------
一些只需要一个对象：注册表、线程池、缓存、对话框、偏好设置等，适合单例模式；
可以通过把构造函数声明为private，然后通过static的getInstance()来获取唯一实例。
例子：巧克力工厂
----------单件模式----------
确保只有一个单例，并提供一个全局访问点。
---------------------------
可以避免其他类自行产生实例。
处理多线程：
	只要把getInstance()变为synchronized，迫使每个线程进入方法前，先等候其他线程离开此方法，但会降低性能，只有第一次执行此方法才真正需要同步。
改进方法：
	getInstance()影响较小，忽略；
	在静态初始化器中创建单件；
	***“双层检查加锁”减少同步：首先检查实例是否创建，如果未创建才同步。
	private volatile static Singleton uniqueInstance;
	public static Singleton getInstance(){
	       if(uniqueInstance == null){
	       	  synchronized(Singleton.class){
			if(uniqueInstance == null){
				uniqueInstance = new Singleton();
			}
		  }
	       }
	       return uniqueInstance;
	}
	volatile确保初始化Singleton实例时，多线程正确处理变量。
类加载器：同时使用类加载器和单件模式，自行指定类加载器，并指定同一个类加载器。
在Java 1.2之前垃圾收集器会回收单件，后来bug修复。
继承单件类，构造器是私有的，不能通过私有构造器扩展类，所以必须把单件的构造器改成公开的或受保护的，并且会导致static被所有子类共享，导致其他错误。
全局变量比单件性能差，因为它会导致急切实例化VS延迟实例化，不能保证只有一个实例，造成命名空间的污染。
----------总结----------
1. 单件模式确保程序中一个类最多只有一个实例；
2. 单件模式也提供访问这个实例的全局点；
3. 在Java中实现单件模式需要私有的构造器、一个静态方法和一个静态变量；
4. 确定在性能上和资源上的限制，然后小心的选择适当的方案来实现单件模式，以解决多线程问题；
5. 使用多个类加载器会导致单件模式失效；
------------------------
----------------------------------------
chapter 6 命令模式
--------------------
1. 客户创建一个命令对象；
2. 客户利用setCommand()将命令对象存储在调用者中；
3. 客户要求调用者执行命令。
Client -> Command -> Invoker -> execute() -> Receiver
**********命令模式**********
将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象，命令模式也支持可撤销的操作。
***************************
客户负责创建一个具体command，并设置接受者，ConcreteCommand定义了动作和接受者之间的绑定关系，调用者只要调用execute()就可以发出请求。
使用堆栈可以实现多层次撤销。
命令模式：队列请求
工作队列类和进行计算的对象之间是完全解耦的。
线程从队列中一个个删除命令对象，然后调用命令执行。
命令模式：日志请求
在Java中，我们可以利用对象序列化实现根据日志恢复，每个命令加入store()和load()记录日志。
----------总结----------
1. 命令模式将发出请求的对象和执行请求的对象解耦；
2. 在被解耦的两者之间是通过命令对象进行沟通的，命令对象封装了接受者和一个或一组动作；
3. 调用者通过调用命令对象的execute()发出请求，这会使接受者的动作被调用；
4. 调用者可以接受命令当做参数，甚至在运行时动态地进行；
5. 命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行前的状态；
6. 宏命令是命令的一种简单的延伸，允许调用多个命令。宏方法也可以支持撤销；
7. 实际操作时，很常见使用“聪明”命令对象，也就是直接实现了请求，而不是将工作委托给接受者；
8. 命令也可以用来实现日志和事务系统。
------------------------
----------------------------------------
chapter 7 适配器模式与外观模式
----------------------------------------
适配器模式中，客户是依据目标接口实现的，适配器实现了目标接口，并持有被适配者的实例。
1. 客户通过目标接口调用适配器的方法对适配器发出请求；
2. 适配器使用被适配器接口接口把请求转换成被适配者的一个或多个调用接口；
3. 客户接收到调用的结果，但并未察觉这一切是适配器在起转换作用。
适配器实现很大接口，有很多东西要做。
一个适配器包装多个被适配者，外观模式；
对于部分期望保留旧厂商接口的可以使用双向的适配器。
**********适配者模式**********
将一个类的接口，转换为客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。
*****************************
适配器可以将改变的部分封装起来，客户不必为了应对不同的接口而每次跟着修改。
两种适配器：对象适配器、类适配器。
类适配器不是使用组合来适配被适配者，而是继承被适配者和目标类。
区别：
对象适配器使用组合，更有弹性；
类适配器使用继承，不需要重新实现整个被适配者。
从枚举到迭代器
装配者和适配器：
  装配者工作与责任有关，新行为加入无需修改现有代码；
  适配器提供解耦，允许客户使用新的库和子集合。
外观模式：让接口更简单。
外观只是提供你更直接的操作，并未将原有的子系统阻隔起来，如果你需要子系统类的更高层功能，还是可以使用原来的子系统。
外观没有封装子系统的类，外观只提供简化的接口，简化系统的同时，依然将系统完整功能暴露出来，以供需要的人使用。
外观模式可以附加新增功能，一个子系统可以创建许多外观。
外观模式允许你将客户实现从任何子系统中解耦。
适配器模式可以将一个或多个类接口变成客户所期望的一个接口。
一个外观也可以只针对一个复杂接口的类提供简化的接口，适配器模式意图改变接口符合客户的期望，外观模式意图提供子系统的一个简化的接口。
**********外观模式**********
提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。
***************************
----------最少知识原则（喷墨式原则）----------
只和你的密友谈话。
---------------------------
当你正在设计一个系统，不管是任何对象，你都要注意它所交互的类有哪些，并注意它和这些类是如何交互的。这个原则希望我们在设计中，不要让太多的类耦合在一起，免得修改系统中的一部分，会影响到其他部分，如果许多类之间相互依赖，那么这个系统就会变成一个易碎的系统，需要更多的成本维护。
在对象方法中，只调用以下方法：
  该对象本身；
  被当做方法的参数而传递进来的对象；
  此方法所创建或所实例化的任何对象；
  对象的任何组件。
如果某对象是调用其他的方法的返回结果，不要调用该对象的方法。
把“组件”想象为是被实例变量所引用的任何对象，把这想象成HAS-A关系。
缺点：导致更多的“包装”类被制造出来，以处理和其他组件的沟通，可能导致复杂度和开发时间增加，降低运行时的性能。
---------------总结---------------
1. 当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器；
2. 当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观；
3. 适配器改变接口以符合客户的期望；
4. 外观将客户从一个复杂的子系统中解耦；
5. 实现一个适配器复杂度根据目标接口的大小与其复杂度而定；
6. 实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行；
7. 适配器两种模式：类适配器、对象适配器；
8. 可以为一个子系统实现一个以上的外观；
9. 适配器讲一个对象包装起来以改变其接口；装饰者将一个对象包装起来以增加新的行为和责任；而外观将一群对象包装起来以简化其接口。
----------------------------------
----------------------------------------
chapter 8 模板方法模式 封装算法
--------------------
找出共同点。
需要由子类提供的方法，必须在超类中声明为抽象；
模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。
---------------模板方法模式---------------
在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
-----------------------------------------
hook是一种被声明在抽象类中的方法，但只有空的或者默认的实现。钩子的存在可以让子类有能力对算法的不同点进行挂钩。
当你的子类“必须”提供算法中某个方法或步骤的实现时，使用抽象方法，如果算法中的这个部分是可选的，就用钩子。如果是钩子的话，子类可以选择实现这个钩子，并不强制做。
钩子用法：
  钩子可以让子类实现算法中可选的部分，或者在钩子对于子类的实现并不重要的时候，子类可以不处理钩子；
  让子类能够有机会对模板方法中某些即将发生的步骤做出反应。
模板方法中子类必须实现抽象类中所有方法。
---------------好莱坞原则---------------
别调用我们，我们会调用你。
---------------------------------------
底层组件绝不可以直接调用高层组件。
依赖倒置原则教我们尽量避免使用具体类，而多使用抽象；
好莱坞原则是在创建框架或组件上的一种技巧，创建一个有弹性的设计，允许底层结构能够互相操作，而又防止其他类太过依赖它们。
----------
模板方法：子类决定如何实现算法中的步骤；
策略：封装可互换的行为，然后使用委托来决定要采用哪一个行为；
工厂方法：由子类决定实例化哪个具体类。
----------
如使用duck implements Comparable完成对对象duck排序。
---------------总结---------------
1. 模板方法定义了算法的步骤，把这些步骤的实现延迟到子类中；
2. 模板方法模式为我们提供了一种代码复用的重要技巧；
3. 模板方法的抽象类可以定义具体方法，抽象方法和钩子；
4. 抽象方法由子类实现；
5. 钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它；
6. 为了防止子类改变模板方法中的算法，可以将模板声明为final；
7. 好莱坞原则将决策权放在高层模块中，以便决定如何以及何时调用底层模块；
8. 策略方法和模板方法都封装方法，一个用组合，一个用继承；
9. 工厂方法是模板方法的一种特殊版本。
-----------------------------------
----------------------------------------
chapter 9 迭代器与组合模式
--------------------
interface Iterator{
  boolean hasNext();
  Object next();
}
迭代器：只需要一个循环就可以多态地处理任何项的集合
---------------迭代器模式---------------
提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示。
---------------------------------------
外部迭代器，客户通过调用next()取得下一个元素；
内部迭代器，迭代器自己控制，必须告诉迭代器在游走过程中，做些什么事情，必须将操作传入给迭代器。
---------------单一责任---------------
一个类应该只有一个引起变化的原因。
-------------------------------------
每个类保持单一责任。
---------------内聚---------------
高内聚：当一个模块或一个类被设计成只支持一组相关的功能时；
低内聚：当被设计成支持一组不相关的功能时。
----------------------------------
Hashtable对于迭代器的支持是“间接的”，从中取元素不是直接去除，而是在它的value取出的。
Collection和Iterator优点：每个Collection都知道如何创建自己的Iterator，只要调用ArrayList上的itreator()，就可以返回一个迭代器。
for(Object obj:collection){
  //
}
对于菜单例子，当需要在餐厅菜单中加入甜点菜单，需要改变：
  需要某种树形结构；
  需要能够在各个菜单各个项之间方便游走；
  需要能够更有弹性地在菜单项之间游走。
---------------组合模式---------------
允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
-------------------------------------
组合模式让我们能用树形方式创建对象的结构，树里面包含了组合以及个别的对象。
使用组合结构，我们能把相同的操作应用在组合和个别对象上，可以忽略对象组合和个别对象之间的差别。
组合、组件、树
  组合包含组件，组件有两种：组合与叶节点元素。
组合模式以单一责任设计原则换区透明性。
对于Menu：
public Iterator createIterator(){
  return new CompositeIterator(menuComponents.iterator());
}
对于MenuItem
public Iterator createIterator(){
  return new NullIterator();
}
组合迭代器：
--------------------
public class CompositeIterator implements Iterator{
  Stack stack = new Stack();
  public CompositeIterator(Iterator iterator){
    stack.push();
  }
  public Object next(){
    if(hasNext()){
      Iterator iterator = (Iterator)stack.peek();
      MenuComponent component = (MenuComponent)iterator.next();
      if(component instanceof Menu){
        stack.push(component.createIterator());
      }
      }else{
        return null;
      }
  }
  public boolean hasNext(){
    if(stack.empty()){
      return false;
    }else{
      Iterator iterator = (Iterator)stack.peek();
      if(!iterator.hasNext()){
        stack.pop();
	return hasNext();
      }else{
        return true;
      }
    }
  }
  public void remove(){
    throw new Exception();
  }
}
--------------------
空迭代器 NullIterator
  对于返回null值，可替代选择是将其hasNext()永远返回false。
组合：通常是树形结构，即层次结构，根是顶层的组合，然后往下是它的孩子，最末端是叶节点。
可以利用缓存提高组合遍历效率。
---------------总结---------------
1. 迭代器允许访问聚合的元素，而不需要暴露它的内部结构；
2. 迭代器将遍历聚合的工作封装进一个对象中；
3. 当使用迭代器的时候，我们依赖聚合提供遍历；
4. 迭代器提供一个通用的接口，让我们遍历聚合项，当我们编码使用聚合的项时，就可以使用多态机制；
5. 我们应该努力让一个类只分配一个责任；
6. 组合模式提供一个结构，可同时包容个别对象的组合对象；
7. 组合模式允许客户对个别对象同时包容个别对象的组合对象；
8. 组合模式允许客户对个别对象以及组合对象一视同仁；
9. 组合结构内的任意对象称为组件，组件可以是组合，也可以是叶节点；
10. 在实现组合模式时，有许多设计上的折中，要平衡透明性和安全性。
-----------------------------------
--------------------chapter 10 状态模式--------------------
策略模式和状态模式是双胞胎。
设计：
  首先，定义一个State接口；
  然后为机器中的每个状态实现状态类；
  最后，将动作委托到状态类。
定义状态接口和类
  首先创建一个State接口，所有状态都必须实现这个接口；
  然后将设计中的每个状态都封装成一个类，每个都实现State接口。
---------------状态模式---------------
允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
-------------------------------------
状态模式：将一群行为封装在状态对象中，context的行为随时可委托到那些状态对象中的一个。随着时间流逝，当前状态在状态对象集合中游走改变，以反映context内部状态，context的行为也会随着改变，但是context的客户对于状态对象了解不多。
策略模式：客户通常主动指定Context所要组合的策略对象是哪一个；把策略模式想成除了继承之外的一种弹性替代方案，把状态模式想成不用context中放置许多条件判断的替代方案。
状态模式中，状态是用在Context中来代表它的内部状态以及行为的，所以只有Context才会对状态提出请求，客户不会直接改变Context的状态；且共享状态实例。
---------------总结---------------
1. 状态模式允许一个对象基于内部状态而拥有不同的行为；
2. 和程序状态机（PSM）不同，状态模式用类代表状态；
3. Context会将行为委托给当前状态对象；
4. 通过将每个状态封装进一个类，我们把以后需要做的任何改变局部化；
5. 状态模式和策略模式有相同的类图，但是它们的意图不同；
6. 策略模式通常会行为或算法来配置Context；
7. 状态模式允许Context随着状态的改变而改变行为；
8. 状态转换可以由State类或Context类控制；
9. 使用状态模式通常会导致设计类的数目大量增加；
10. 状态类可以被多个Context实例共享。
------------------------------------
-------------------------chapter 11 代理模式-------------------------
代理可以假装自己是远程对象，但其实只是一个中间的角色。
客户对象所做的就像是在做远程方法调用，但其实只是调用本地堆的“代理”对象上的方法，再由代理处理所有网络通信的底层细节。
Duck d = <另一个堆的对象>
使用RMI进行创建。
---------------远程方法---------------
客户辅助对象会乔装为服务对象，但是不是真正的远程服务，并不真正拥有远程服务的方法和逻辑，客户辅助对象会联系服务器，传入方法调用信息，等待服务器返回。
服务器端，服务辅助对象通过Socket接受请求，将调用信息解包，然后调用真正服务对象的真正方法，得到返回值，打包，返回客户辅助对象，客户辅助对象对信息解包，最后将返回值交给客户对象。
这里客户辅助对象是个代理。
---------------RMI概观---------------
RMI提供了客户辅助对象和服务器辅助对象，为辅助对象创建和服务对象相同的方法，可以不用亲自写任何网络或I/O代码。
查找服务：用来寻找和访问远程对象。
客户辅助对象：RMI STUB；
服务辅助对象：RMI SKELETON。
----------制作远程服务----------
-----步骤一：制作远程接口-----
远程接口定义出可以让客户远程调用的方法，客户将用它作为服务的类类型，Stub和实际的服务都实现此接口。
1. 扩展java.rmi.Remote
Remote不具有方法；
public interface MyRemote extends Remote
2. 声明所有方法都会抛出RemoteException
客户会调用实现远程接口的Stub上的方法，Stub底层用到了网络和I/O，所以有风险，必须处理或声明远程异常来解决，如果接口中声明了异常，任何在接口类型的引用上调用方法的代码也必须处理或者声明异常。
3. 确定变量和返回值属于原语类型或者可序列化
远程方法的变量和返回值必须是原语类型或Serializable类型。
-----步骤二：制作远程的实现-----
实际工作类，提供真正的实现。
1. 实现远程接口
客户将要调用的方法的接口。
2. 扩展UnicastRemoteObject
使对象具有远程的功能，扩展java.rmi.UnicastRemoteObject。
3. 设计一个不带变量的构造器，声明RemoteException
超类抛出异常，子类也抛出。
4. 注册RMI Registry服务
将服务实例化，然后放进RMI registry中。
java.rmi.Naming.rebind();
-----步骤三：利用rmic产生的stub和skeleton-----
客户和服务的辅助类。
在远程实现类上执行rmic。
rmic MyRemoteImpl
-----步骤四：启动RMI registry-----
用户可以从中查找代理位置。
开启终端，启动rmiregistry，启动目录可以访问类，从classes目录启动。
-----步骤五：开始远程服务-----
服务对象运行，服务类会实例化一个服务实例，并将服务注册到RMI registry。
启动服务。
--------------------------------
----------客户获取stub对象----------
使用RMI Registry获取，如下：
MyRemote service = (MyRemote) Naming.lookup("rmi://127.0.0.1/RemoteHello");
实际上不需要知道远程服务真正类名。
-----工作方式-----
1. 客户到RMI registry中寻找
Naming.lookup();
2. RMI registry返回Stub对象
RMI会自动反序列化，客户端必须有stub类，否则无法反序列化。
3. 客户调用Stub的方法。
扩展：动态类下载，发现没有本地类，会使用HTTP的GET获取类文件。
注意：
1. 启动远程服务之前启动rmiregistry；
2. 不要忘记变量和返回值的类型成为可序列化类型；
3. 客户端也需要stub，但不引用stub类。
--------------------
public interface State extends Serializable{
}
public class NoQuarterState implements State{
  transient GumballMachine gumballMachine;
  //不序列化
}
----------过程----------
1. 先通过RMI registry取得代理；
2. 然后调用方法，通过Stub调用被转向远程服务，Skeleton收到请求，发给远程实现类；
3. 远程实现类将结果返回给skeleton，然后序列化，通过网络传回客户端代理。
----------代理模式----------
代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。
---------------------------
代理方式变体：
  远程代理控制访问远程对象；
  虚拟代理控制访问创建开销大的资源；
  保护代理基于权限控制对资源的访问。
代理负责远程实现类的创建与销毁，控制了访问。
---------------虚拟代理---------------
虚拟代理作为创建开销大的对象的代表，虚拟代理经常知道我们真正需要一个对象的时候才创建它，当对象创建前或创建中，虚拟代理扮演对象本身，创建后代理会将请求直接委托给对象。
如在线音乐显示CD封面，在网络图片加载出来之前，再是显示其他默认图片。
----------ImageProxy----------
1. ImageProxy首先创建一个ImageIcon，然后开始从网络上获取图像；
2. Imageproxy显示加载中；
3. 加载完毕，调用委托给真正的ImageIcon；
4. 重复此类过程。
------------------------------
缓存代理：会维护之前创建的对象，当收到请求时，在可能的情况下返回缓存对象。
-----装饰者模式和代理模式-----
装饰者模式为对象增加行为，代理模式是控制对象的访问；
可以使用工厂模式，实例化并返回主题，可以让客户使用代理而不是真正的对象，但客户并不知道。
----------------------------
-----适配器模式和代理模式-----
都是挡在其他对象的前面，并负责将请求转发给它们，适配器会改变对象适配的接口，代理则实现相同的接口。
保护代理：可以根据客户角色决定客户访问特定方法。
---------------------------
----------保护代理----------
动态代理：使用java.lang.reflect，动态创建代理类。
PersonBean{
String name;
String gender;
String interests;
int rating;
int ratingCount = 0;
}
顾客不可以改变自己的HotOrNot评分，也不可以改变他人的信息。一次创建两个代理：
一个访问自己的PersonBean对象；另一个访问另一个顾客的PersonBean。
---------------
动态代理：并不是运行时实例化，运行时才将它的类创建出来，代码执行时，没有proxy类，它是根据需要从传入的接口集创建的。
代理类静态方法isProxyClass()判断是否为代理类，代理类会实现特定的某些接口。
传入的newProxyInstance()接口类型限制：接口数组中只能有接口不能有类，如果接口不是public，就必须是同一个package，不同的接口内，不可以有名称和参数完全一样的方法。
为什么使用skeleton：概念上帮助理解。
Java 5中stub不需要产生：RMI和动态代理搭配使用，动态代理产生stub，远程对象的stub是java.lang.reflect.Proxy实例，自动产生，来处理所有把客户的本地调用变成远程调用的细节。
---------------
防火墙代理：控制网络资源的访问，保护主题免于“坏用户”的侵害。
智能引用代理：当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数。
缓存代理：为开销大的运算结构提供暂时储存：它允许多个客户共享结果，以减少计算或网络延迟。
同步代理：在多线程的情况下为主题提供安全的访问。
复杂隐藏代理：用来隐藏一个类的复杂集合的复杂度，并进行访问控制。有时也称为外观代理。
写入时复制代理：用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止，虚拟代理的变体。
---------------总结---------------
1. 代理模式为另一个对象提供代表，以便控制客户对对象的访问，管理访问的方式有许多种。
2. 远程代理管理客户和远程对象之间的交互。
3. 虚拟代理控制访问实例化开销大的对象。
4. 保护代理基于调用者控制对象方法的访问。
5. 代理在结构上类似装饰者，但是目的不同。
6. 装饰者模式为对象加上行为，而代理则是控制访问。
7. Java内置的代理支持，可以根据需要建立动态代理，并将所有调用分配到所选的处理器。
8. 代理会造成设计类数目增加。
-----------------------------------
--------------------chapter 12 复合模式 模式的模式--------------------
复合模式在一个解决方案中结合两个或多个模式，已解决一般或重复发生的问题。
----------鸭子模拟器----------
1. 首先，创建Quackable接口；
  public interface Quackable{
    public void quack();
  }
2. 某些鸭子实现Quackable接口；
  public class MallarDuck implements Quackable{
    public void quack(){
      System.out.println("Quack");
    }
  }
  public class RedheadDuck implements Quackable{
    public void quack(){
      System.out.println("Quack");
    }
  }
3. 模拟鸭叫模拟器
  public class DuckSimulator{
  }
4. 当鸭子出现，鹅在附近。
  public class Goose{
    public void honk(){
      System.out.println("Honk");
    }
  }
5. 鹅适配器
  public class GooseAdapter implements Quackable {
    Goose goose;
    public GooseAdapter(Goose goose){
      this.goose = goose;
    }
    public void quack(){
      goose.honk();
    }
  }
6. 使用模拟器模拟鹅和鸭
  public class DuckSimulator{
    public static void main(String[] args){
      DuckSimulator simulator = new DuckSimulator();
      simulator.simulate();
    }
    void simulate(){
      Quackable duck1 = new Mallarduck();
      Quackable duck2 = new RedheadDuck();
      Quackable duck3 = new DuckCall();
      Quackable duck4 = new RubberDuck();
      Quackable goose = new GooseAdapter(new Goose());
      //invoke simulate
    }
    void simulate(Quackable duck){
      duck.quack();
    }
  }
8. 计算叫声的次数
  装饰者模式
  public class QuackCounter implemets Quackable{
    Quackable duck;
    static int numberOfQuacks;
    public QuackCounter(Quackable duck){
      this.duck = duck;
    }
    public void quack(){
      duck.quack();
      numberOfQuacks++;
    }
    public static int getQuacks(){
      return numberOfQuacks;
    }
  }
9. 需要修改模拟器创建装饰者
  这里直接将DuckSimulator中new Quackable修改为new QuackCounter。
10. 工厂模式产生鸭子
  public abstract class AbstractDuckFactory{
    public abstract Quackable createMallardDuck();
    public abstract Quackable createRedheadDuck();
    public abstract Quackable createDuckCall();
    public abstract Quackable createRubberDuck();
  }
  public class DuckFactory extends AbstractDuckFactory{
    public Quackable createMallardDuck(){
      return new MallardDuck();
    }
    public Quackable createRedheadDuck(){
      return new RedheadDuck();
    }
    public Quackable createDuckCall(){
      return new DuckCall();
    }
    public Quackable createRubberDuck(){
      return new RubberDuck();
    }
  }
  创建真正的工厂：
  public class CountingDuckFactory extends AbstractDuckFactory{
    public Quackable createMallardDuck(){
      return new QuackCounter(new MallardDuck());
    }
    public Quackable createRedheadDuck(){
      return new Quackable(new RedheadDuck());
    }
    public Quackable createDuckCall(){
      return new Quackable(new DuckCall());
    }
    public Quackable createRubberDuck(){
      return new Quackable(new RubberDuck());
    }
  }
11. 模拟器使用工厂
  public class DuckSimulator{
    public static void main(String[] args){
      DuckSimulator simulator = new DuckSimulator();
      AbstractDuckFactory duckFactory = new CountingDuckFactory();
      simulate.simulate(duckFactory);
    }
    void simulate(AbstractDuckFactory duckFactory){
      Quackable duck1 = duckFactory.createMallardDuck();
      Quackable duck2 = duckFactory.createRedheadDuck();
      Quackable duck3 = duckFactory.createDuckCall();
      Quackable duck4 = duckFactory.createRubberDuck();
      Quackable goose = new GooseAdapter(new Goose());
      //invoke next simulate method
    }
    void simulate(Quackable duck){
      duck.quack();
    }
  }
12. 管理一群鸭子
  public class Flock implemets Quackable{
    ArrayList quakers = new ArrayList();
    public void add(Quackable quacker){
      quakers.add(quacker);
    }
    public void quack(){
      Iterator iterator = quackers.iterator();
      while(iterator.hasNext()){
        Quackable quacker = (Quackable)iterator.next();
	quacker.quack();
      }
    }
  }
13. 修改模拟器
  只需要
  Flock flockDuck = new Flock();
  flockDuck.add(/*duck*/);
  即可
14. 需要Observable接口
  监视鸭子
  Observable 需要注册和通知观察者的方法：
  public interface QuackObservable{
    public void registerObserver(Observer observer);
    public void notifyObservers();
  }
  public interface Quackable extends QuackObservable{
    public void quack();
  }
15. 现在我们必须确定所有实现Quackable的具体类都能够扮演QuackObservable的角色。
  public class Observable implements QuackObservable{
    ArrayList observers = new ArrayList();
    QuackObservable duck;
    public Observable(QuackObservable duck){
      this.duck = duck;
    }
    public void registerObserver(Observer observer){
      Interator iterator = observer.iterator();
      while(iterator.hasNext()){
        Observer observer = (Observer)iterator.next();
	observer.update(duck);
      }
    }
  }
16. 整合Observable辅助类和Quackable类
  public class MallarDuck implements Quackable{
    Observable observable;
    public MallarDuck(){
      observable = new Observable(this);
    }
    public void quack(){
      System.out.println("Quack");
      notifyObservers();
    }
    public void registerObserver(Observer observer){
      observer.registerObserver(observer);
    }
    public void notifyObservers(){
      observable.notifyObservers();
    }
  }
17. 实现Observer
  public interface Observer{
    public void update(QuackObservable duck);
  }
  public class Quacklogist implements Observer{
    public void update(QuackObservable duck){
      System.out.println("Quacklogist: " + duck + " just quacked.");
    }
  }
18. 观察鸭子行为
  Quacklogist quacklogist = new Quacklogist();
  //一群鸭子
  flockDuck.registerObserver(quacklogist);
----------问题----------
1. 复合模式不单单是一群模式携手合作，是指一群模式被结合起来使用，以解决一般性问题。
2. 复合模式不是遇到问题逐一解决。
------------------------
以上使用模式：
  适配器模式：想要适配鹅；
  装饰者模式：追踪鸭子叫次数；
  工厂模式：产生装饰者鸭子；
  迭代器模式：方便管理多个鸭子；
  观察者模式：监视鸭子叫。
--------------------MVC--------------------
视图：用来呈现模型，视图通常直接从模型中取得他需要显示的状态与数据。
控制器：取得用户的输入并解读其对模型的意思。
模型：模型持有所有的数据、状态和程序逻辑，模型没有注意到视图和控制器，虽然它提供了操纵和检索状态的接口，并发送状态改变通知给观察者。
步骤	发出者	接受者	动作
1	视图	控制器	用户做某件事
2	控制器	模型	改变状态
3	控制器	视图	改变显示
4	模型	视图	通知视图模型改变
7	视图	模型	我需要你的状态信息
----------解释----------
用户——和视图交互
  视图是模型的窗口，当用户对视图做些事，视图会告诉控制器做了什么，控制器负责处理；
控制器要求模型改变状态
  控制器解读用户动作，按下按钮，控制器理解这个动作意义，并告知模型作何动作；
控制器也可能要求视图改变
  当控制器从视图接收到某一动作，结果可能是它也需要知道视图改变及其结果。
当模型改变时，模型会通知视图
  只要当模型内的东西改变时，模型就会通知视图它的状态改变了。
视图向模型询问状态
  视图直接从模型取得它的显示状态。当控制器请求视图改变时，视图也可能向模型询问某些状态。
----------问题----------
控制器可以变成模型的观察者吗？
  可以，某些设计中，控制器会向模型注册，模型已有改变就通知控制器。
控制器做的事情不只有将操作发送给模型，还会解读输入，并根据输入操纵模型，但至于为什么不放进视图中：
  A. 会让视图代码变得复杂，因为这样会让视图有两个责任，管理用户界面和控制模型的逻辑；
  B. 将会造成模型和视图之间紧耦合，如果想复用此视图来处理其他模型是不可能的，控制器将视图和模型分离，使设计更有弹性更容易扩展。
-------------------------
看待MVC
  1. 模型利用“观察者”让控制器和视图之间可以随最新的状态改变而更新；另一方面，视图和控制器则实现了“策略模式”。控制器是视图的行为，如果不希望有这样的行为，可以直接换一个控制器，试图内部使用组合模式来管理窗口，按钮以及其他显示组件。
  2. 视图和控制器的策略模式：
    A. 视图是一个对象，可以被调整为使用不同的策略，而控制器提供了策略。
    B. 视图只关心系统中可视的部分，对于任何界面行为，都委托给控制器处理。
    C. 使用策略模式也可以让视图和模型之间的关系解耦，因为控制器负责和模型交互来传递用户的请求。
  3. 组合：视图是GUI组件的组合。
-------------------------
实例：利用MVC控制节拍
  控制器了解了视图的行为，然后使用Model的方法。
  ----------
  创建碎片
  public interface BeatModelInterface{
    //控制器调用，对模型处理
    void initialize();
    void on();
    void off();
    void setBPM();
    //允许视图和控制器取得状态，并变成观察者
    int getBPM();
    void registerObserver(BeatObserver o);
    void removeObserver(BeatObserver o);
    void registerObserver(BPMObserver o);
    void removeObserver(BPMObserver o);
  }
  具体BeatModel类
  public class BeatModel implements BeatModelInterface,MetaEventListener{
    Sequencer sequencer;
    ArrayList beatObservers = new ArrayList();
    ArrayList bpmObservers = new ArrayList();
    int bpm = 90;
    //下面实现方法
  }
  实现视图
  public class DJView implements ActionListener,BeatObserver, BPMObserver{
    BeatModelInterface model;
    ControllerInterface controller;
    //swing组件
    public void actionPerformed(ActionEvent event){
      if(event.getSource() == setBPMButton){
        controller.setBPM(bpm);
      }
      //其他监视事件
    }
  }
  实现控制器
  public interface ControllerInterface{
    void start();
    void stop();
    void increaseBPM();
    void decreaseBPM();
    void setBPM(int bpm);
  }
  public class BeatController implements ControllerInterface{
    BeatModelInterface model;
    DJView view;
    public BeatController(BeatModelInterface model){
      this.model = model;
      //initialize view
      model.initialize();
    }
    public void start(){
      model.on();
      view.disableStartMenuItem();
    }
    //stop(), increaseBPM(), descreaseBPM(), setBPM()
  }
--------------------
探索策略
  HeartModel
    getHeartRate()
    registerBeatObserver()
    registerBPMObserver()
  为了能让复用之前视图和HeartModel搭配：
适配模式
  MVC技巧：使用适配器将模型适配成符合现有视图和控制器的需要的模型。
  public class HeartAdapter implements BeatModelInterface{
    HeartModelInterface heart;
    public HeartAdapter(HeartModelInterface heart){
      this.heart = heart;
    }
    public initialize(){}
    public void on(){}
    public void off(){}
    public int getBPM(){
      return heart.getHeartRate();
    }
    //setBPM
    public void registerObserver(BeatObserver o){
      heart.registerObserver(o);
    }
    //removeObserver
    public void registerObserver(BPMObserver o){
      heart.registerObserver(o);
    }
    //removeObserver
  }
  然后实现HeartController
  public class HeartController implements ControllerInterface{
    HeartModelInterface model;
    DJView view;
    public HeartController(HeartModelInterface model){
      this.model = model;
      //初始化view
    }
    public void start(){}
    //stop increserBPM decreaseBPM setBPM
  }
--------------------
MVC与Web
步骤	发送方		接收方		动作
1	客户		servlet/控制器	HTTP请求
2	servlet/控制器	bean		实例化
3	servlet/控制器	jsp/视图
4	bean		jsp/视图
5	jsp/视图	客户		HTTP响应
  1. 客户发送一个会被Servlet收到的HTTP请求
  2. Servlet扮演控制器
    处理客户请求，通常会向模型（数据库）发送请求，处理结果以Bean形式打包
  3. 控制器将控制权交给视图
    视图就是JSP，JSP唯一工作就是产生界面，表现模型的视图
  4. 视图通过HTTP将页面返回浏览器
    页面返回浏览器，作为视图显示出来，客户提出进一步请求，以同样的方式处理
--------------------
设计手机DJ程序
  1. 修正模型（模型）
    模型对视图和控制器一无所知，完全解耦，模型只知道有一些观察者需要通知。
  2. 创建Servlet控制器（控制器）
    处理Web请求
  3. 创建HTML视图（视图）
    jsp界面
Model2的观察者模式：
  这里没有向模型注册接受状态以改变通知，当模型改变时，视图可以间接地从控制器收到相当于通知的东西，控制器把Bean送给视图，如果考虑B/S模式，视图在HTTP响应返回到浏览器时只需要一个状态信息的更新，随时的通知是没有意义的，只有当页面被创建和返回时，创建视图并结合模型状态才有意义。
  也就是说，视图的更新并不是在每次模型状态改变时，而是有页面请求时，视图从控制器接受通知。
Model2的策略模式：
  在Model2中，策略对象依然是控制器Servlet，但它不是直接和视图结合，策略对象为视图实现行为，当想要不同行为时，可以直接把控制器换掉。
Model2的组合模式：
  由网页浏览器呈现的HTML描述，内部仍然是一个形成组合的对象系统。
  控制器还是提供视图的行为，只不过它不再用对象组合直接和视图结合在一起。
--------------------
1. 组合模式真的在MVC中吗？
  GUI组件以及浏览器对标记语言的生成界面。
2. 控制器会实现应用逻辑吗？
  NO，控制器为视图实现行为，将来自视图的动作转成模型上的动作，模型实现应用逻辑，并决定如何响应动作，控制器也需要做一些决定，决定调用哪个模型的哪个方法，但不是“应用逻辑”，应用逻辑是指管理与操纵你的模型中的数据的代码。
3. Why Model？
  深入理解。
4. MVC用到了状态模式吗?
  NO，Model的状态指一般意义上的状态，但的确有些模型使用状态模式。
5. 控制器是中介者吗？
  中介者的意图是封装对象之间的交互，不让两个对象互相显示引用，以达到松耦合的目的。
  在某种程度上，可以视为中介者，视图不会直接设置模型的状态，而是通过控制器进行，视图的确是持有用来访问模型状态的模型引用，如果是彻底终结者，那么视图就必须通过控制器才能取得模型的状态。
6. 视图一定要向模型询问状态吗？为什么不在更新通知时用推送模型，顺便把模型状态送过去？
  可以在通知的时候把状态送过去，事实上，如果检查JSP/HTML会发现，我们把模型状态包成Bean发送，然后视图就用Bean属性来访问状态。
7. 如果有两个以上视图，是不是一定需要两个以上控制器？
  通常一个配一个，但也可以一个控制类管理多个视图。
8. 视图不应该操纵模型，但是注意到在实现中，模型的那些改变状态的方法并没有对视图设限，有安全风险吗？
  给视图完全的权限，这里只是为了简单，你可以只给视图访问模型的部分API，允许你适配一个接口，只提供一个子集。
---------------总结---------------
1. MVC是复合模式，结合了观察者模式、策略模式和组合模式。
2. 模型使用观察者模式，以便观察者更新，同时保持两者之间的解耦。
3. 控制器是视图的策略，试图可以使用不同的控制器实现，得到不同的控制行为。
4. 视图使用组合模式实现用户界面，用户界面通常组合了嵌套的组件。
5. 这些模式把MVC模型三成解耦，保持设计有弹性。
6. 适配器模式可以将新的模型适配成已有的视图和控制器。
7. Model 2是MVC在Web上的应用。
8. 在Model 2中，控制器实现成Servlet，而JSP/HTML实现视图。
----------------------------------
--------------------chapter 13 真实世界中的模式--------------------
---------------设计模式---------------
模式是在某情景下，针对某问题的某种解决方案。
情景：应用某个模式的情况。
问题：想在某情景下达到的目标，也可以是约束。
解决方案：一个通用的设计，用来解决约束，达到目标。
-------------------------------------
模式：
  意图		Intent
  动机		Motivation
  适用性	Applicability
  结构		Structure
  参与者	Particopants
  协作		Collaborations
  结果		Consequences
  实现		ImplementationSample Code
  已知应用	Known Uses
  相关模式	Ralated Patterns
三次原则：真实世界应用三次以上。
模式分类：
  创建型：涉及到对象实例化，都提供一个方法，将客户从所需要实例化的对象中解耦；如：
    Singleton, Builder, Prototype, Abstract Factory, Factory Method
  行为型：涉及到类和对象如何交互及分配职责；
    Template Method, Visitor, Mediator, Iterator, Command, Memento, Observer, Chain of Responsibility, State, Strategy
  结构型：可以让你把类或对象组合到更大的结构中。
    Decorator, Proxy, Composite, Facade, Flyweight, Bridge, Adapter
另一种分类方式：
  类：描述类之间的关系如何通过继承定义，在编译时建立。
    Template Method, Adapter, Factory Method, Interpreter
  对象：描述对象之间的关系，而且主要是利用组合定义，对象模式的关系通常在运行时建立，而且更加动态、更有弹性。
    Composite, Decorator, Proxy, Strategy, Bridge, Flyweight, Abstract Factory, Singleton, Visitor, Command, Facade, Chain of Responsibility, Mediator, Prototype, Builder, Iterator, Memento, Observer, State
---------------反模式---------------
反模式告诉你如何采用一个不好的解决方案解决一个问题。
-----------------------------------
--------------------总结--------------------
1. 让设计模式自然而然地出现在你的设计中，而不是为了使用而使用；
2. 设计模式并非僵化的教条，你可以根据自己的需要采用或调整；
3. 总是使用满足需要的最简单解决方案，不管它用不用模式；
4. 学习设计模式的类目，可以帮你自己熟悉这些模式以及它们之间的关系；
5. 模式的分类是将模式分成不同的族群；
6. 你必须相当专注才能够成为一个模式的作家；
7. 所遇到的大多数的模式都是现有模式的变体，而非新的模式；
8. 模式能够为你带来的最大好处之一是：让你的团队拥有共享词汇；
9. 更好的在社区交流。
--------------------------------------------
--------------------chapter 14 其他模式--------------------
--------------------桥接模式--------------------
桥接（Bridge Pattern）不只改变你的实现，也改变你的抽象。
场景：
  彻底改变“极限休息室”，让所有的遥控器基于相同的抽象，每部不同型号的电视都有自己的遥控器实现。
  困难：遥控器会改变，电视机也会改变，已经将界面抽象出来，但随着时间的增长，用户也会提出一些想法，要求改变抽象。
桥接模式优点：
  1. 将实现解耦，让它和界面之间不再永久绑定；
  2. 抽象和实现可以独立扩展，不会影响到对方；
  3. 对于“具体的抽象类”所做的改变，不会影响到客户。
桥接的用途和缺点：
  1. 适合使用在需要跨越多个平台的图形和窗口系统上；
  2. 当需要用不同的方式改变接口和实现时，桥接模式很好用；
  3. 桥接模式缺点增加了复杂度。
--------------------生成器--------------------
使用生成器模式（Builder Pattern）封装一个产品的构造过程，并允许按步骤构造。
场景：
  为一个主题公园制定一个度假计划，客人可以选择旅馆、门票、餐厅订位，
  弹性设计：每个客人度假计划不一样，弹性的数据结构。
生成器优点：
  1. 将一个复杂对象的创建过程封装起来；
  2. 允许对象通过多个步骤来创建，并且可以改变过程；
  3. 向客户隐藏产品内部的表现；
  4. 产品的实现可以被替换，因为客户只看到一个抽象的接口。
生成器的用途和缺点：
  1. 经常被用来创建组合结构；
  2. 和工厂模式相比，采用生成器模式创建对象的客户，需要具备更多的领域知识。
--------------------责任链模式--------------------
当你想要让一个以上的对象有机会能够处理某个请求的时候，就是用责任链模式。（Chain of Responsibility Pattern）
场景：
  把发送到企业的邮件分发到对应部门。
通过责任链模式，你可以为某个请求创建一个对象链，每个对象依序检查请求，并对其进行处理，或者将它传给链中的下一个对象。
责任链的优点：
  1. 把请求的发送者和接收者解耦；
  2. 可以简化你的对象，因为它不需要知道链的结构；
  3. 通过改变链内的成员或调动它们的次序，允许你动态地新增或者删除责任。
责任链的用途和缺点：
  1. 经常被使用在窗口系统中，处理鼠标和键盘之类的事件；
  2. 并不保证请求一定会被执行，如果没有任何对象处理它的话，它可能会落到链尾端；
  3. 可能不容易观察运行时的特征，有碍于出错。
--------------------蝇量模式--------------------
如果让某个类的实例能用来提供许多“虚拟实例”，就使用蝇量模式（Flyweight Pattern）。
场景：
  如在一个景观设计中，想要再XY处加上树作为点缀，树可以根据自己的树龄自己绘制。
  困难：创建多个树，使用class Tree.display()程序会呆滞。
这里可以采用一个class
TreeManger
属性：treeArray
方法：displayTrees(){调用Tree.display()}
蝇量的优点：
  1. 减少运行时对象实例的个数，节省内存；
  2. 将许多虚拟对象的状态集中管理；
蝇量的用途和缺点：
  1. 当一个类有许多的实例，而这些实例能够被同一方法控制的时候，可以使用；
  2. 缺点：一旦你实现了它，那么单个的逻辑实例将无法拥有独立而不同的行为。
--------------------解释器模式--------------------
使用解释器模式（Interpreter Pattern）为语言创建解释器。
可以使用语言控制鸭子模拟器。
当你需要实现一个简单的语言时，就是用解释器模式定义语法的类，并用一个解释器解释句子，每个语法规则都用一个类代表。
解释器模式的优点：
  1. 将每一个语法规则表示成一个类，方便于实现语言；
  2. 因为语法有许多类表示，所以你可以轻易地改变或扩展此语言；
  3. 通过在类结构中加入新的方法，可以在解释的同时增加新的行为；
解释器的用途和缺点：
  1. 当你实现一个简单的语言时，使用解释器；
  2. 当你有一个简单的语法，而且简单比效率更重要使用解释器；
  3. 可以处理脚本语言和编程语言；
  4. 当语法规则的数目太大时，模式会十分复杂。
--------------------中介者模式--------------------
使用中介者模式（Mediator Pattern）来集中相关对象之间复杂的沟通和控制方式。
场景：
  Java版本的自动屋，可以帮助使用者做一些事。
  困难：想要持续地追踪每一个对象的每个规则，十分复杂。
使用中介者：当每个对象状态改变时，告诉中介者；每个对象向中介者发出的请求做出回应。
中介者的优点：
  1. 通过将对象彼此解耦，可以增加对象的复用性；
  2. 通过将控制逻辑集中，可以简化系统的维护；
  3. 可以让对象之间所传递的消息变得简单而且大幅减少。
中介者的用途和缺点：
  1. 中介者常常被用来协调相关的GUI组件；
  2. 缺点：如果设计不当，中介者对象本身会变得过于复杂。
--------------------备忘录模式--------------------
当你需要让对象返回之前的状态时，使用备忘录模式（Memento Pattern）。
场景：
  游戏存储游戏进度。
备忘录目标：
  1. 储存系统关键对象的重要状态；
  2. 维护关键对象的封装。
备忘录的优点：
  1. 将被储存的状态放在外面，不要和关键对象混在一起，可以帮助维护内聚
  2. 保持关键对象的数据封装；
  3. 提供了容易实现的恢复能力。
备忘录的用途和缺点：
  1. 备忘录用于储存状态；
  2. 使用备忘录的缺点：储存和恢复状态的过程可能相当耗时；
  3. 在Java中，可以考虑序列化机制存储系统状态。
--------------------原型模式--------------------
当创建给定类的实例的过程很昂贵或很复杂时，就使用原型模式（Prototype Pattern）。
场景：
  游戏场景中怪兽随着场景的改变而变化。
原型模式允许你通过复制现有的实例来创建新的实例，客户在不知道要实例化特定类的情况下，可以制造出新的实例。
原型的优点：
  1. 向客户隐藏了制造新实例的复杂性；
  2. 提供让客户能够产生未知类型对象的选项；
  3. 在某些环境下，复制对象比创建新对象更有效。
原型的用途和缺点：
  1. 在一个复杂的类的层次中，当系统必须从其中的许多类型创建新对象时，可以考虑原型；
  2. 使用原型模式的缺点：对象的复制有时相当复杂。
--------------------访问者模式--------------------
当你想要为一个对象的组合增加新的能力，且封装并不重要时，就使用访问者模式（Visitor Pattern）。
场景：
  查看餐厅菜单的详细情况。
访问者必须参观组合内的每个元素，访问者通过导游的引导，收集组合中所有对象的状态，一旦状态被收集了，客户就可以让访问者对状态进行各种操作，当加入新的功能，只要加强访问者即可。
访问者的优点：
  1. 允许你对组合结构加入新的操作，而无需改变结构本身；
  2. 想要加入新的操作，相对容易；
  3. 访问者所进行的操作，其代码是集中在一起的。
访问者的用途和缺点：
  1. 当采用访问者模式的时候，就会打破组合类的封装；
  2. 因为游走的功能牵涉其中，所以对组合结构的改变就更加困难。
------------------------------END------------------------------
