Head First设计模式
----------------------------------------
chapter 01 设计模式
--------------------
1. 模拟鸭子
利用继承会导致很难知道鸭子的所有行为，改变base，会导致所有都改变，解决方法，接口。
2. 接口
将fly()和quack()封装为接口flyable()和quackable()，但是会增加代码量，如果每个会飞会叫都要重写方法，因此，该方法并不适合。
*设计原则：找出可能需要变化的部分，把他独立出来，不要和那些不需变化的混在一起，即把会变化的部分封装起来。
3. 设计鸭子的行为
*设计原则：针对接口编程，而不是针对实现编程（针对超类型编程）。
将fly()接口先实现为两个：会飞、不会飞。
针对超类型编程：变量的声明类型应该是超类型，通常是一个抽象类或者是一个接口，只要具体实现此超类型的类所产生的对象，都可以指定给这个变量。
实现多态：
Animal animal = new Dog();
animal.makeSound();
可以通过setter动态设置行为。
----------------------------------------
chapter 02 观察者模式
--------------------
观测者模式：气象站、WeatherData对象、布告板；
当天气数据更新时，需要更新布告板数据，传统做法是直接在measurementsChanged()写更新方法，但是当删除布告板时，需要修改此方法，较为麻烦。
当数据更新时，主题就会把数据更新到观察者对象。
*观察者模式定义了对象之间一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。 是一种一对多的关系。
是一种松耦合的关系，有新类型的观察者出现时，主题的代码不需要修改，因为主题唯一依赖的东西是一个实现，Observer接口的对象列表，所以我们可以随时增加观察者。
改变主题或观察者其中一方，并不会影响另一方。
*设计原则：为了交互对象之间的松耦合设计而努力。
JavaAAPI有内置的观察者模式。java.util包（package）内包含最基本的Observer接口与Observable类。
Observable类追踪所有的观察者，并通知他们。Observable是一个“类”，而不是一个接口。
观察者要如何送出通知：
	先调用setChanged()方法，标记状态已经改变的事实；
	然后调用两种notifyObservers()方法中的一个。
观察者如何接收通知：
	如果你想“推”（push）数据给观察者，你可以把数据当作数据对象传送给notifyObservers(arg)方法。否则，观察者就必须从可观察者对象中“拉”（pull）数据。
	setChanged()方法可以让你在更新观察者时，有更多的弹性，你可以更适当地通知观察者。
java.util.Observable的黑暗面：
	可观察者是一个“类”而不是一个“接口”，更糟的是，它甚至没有实现一个接口。限制了它的使用和复用。
Observable是一个类：
	如果某类想同时具有Observable类和另一个超类的行为，就会陷入两难，限制了Observable的复用潜力，Observable将关键的方法保护起来，除非你继承自Observable，否则你无法创建Observable实例并组合到你自己的对象中来。

********************
总结
OO基础:抽象；
OO原则：
	封装变化
	多用组合，少用继承
	针对接口编程，不针对实现编程
	为交互对象之间的松耦合设计而努力
OO模式：观察者模式：
	在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象都会收到通知，并自动更新。
1. 观察者模式定义了对象之间一对多的关系。
2. 主题（也就是可观察者）用一个共同的接口来更新观察者
3. 观察者和可观察者之间用松耦合方式结合（loosecoupl-ing），可观察者不知道观察者的细节，只知道观察者实现了观察者接口。
4. 使用此模式时，你可从被观察者处推（push）或拉（pull）数据（然而，推的方式被认为更“正确”）。
5. 有多个观察者时，不可以依赖特定的通知次序。
6. Java有多种观察者模式的实现，包括了通用的java.util.Observable。
7. 要注意java.util.Observable实现上所带来的一些问题。
8. 如果有必要的话，可以实现自己的Observable，这并不难，不要害怕。
9. Swing大量使用观察者模式，许多GUI框架也是如此。
10. 此模式也被应用在许多地方，例如：JavaBeans、RMI。
----------设计原则----------
1. 找出程序中会变化的方面，然后将其和固定不变的方面相分离；
在观察者模式中，会改变的是主题的状态，以及观察者的数目和类型。用这个模式，你可以改变依赖于主题状态的对象，却不必改变主题。这就叫提前规划！
2. 针对接口编程，不针对实现编程；
主题与观察者都使用接口：观察者利用主题的接口向主题注册，而主题利用观察者接口通知观察者。这样可以让两者之间运作正常，又同时具有松耦合的优点
3. 多用组合，少用继承。
观察者模式利用“组合”将许多观察者组合进主题中。对象之间的这种关系不是通过继承产生的，而是在运行时利用组合的方式而产生的。
---------------------------
----------------------------------------

----------------------------------------
chapter 3装饰者模式
--------------------
**********开放-关闭原则**********
类应该对扩展开放，对修改关闭。
********************************
目标：允许类容易扩展，在不修改现有代码的情况下，就可搭配新的行为。
遵循开放-关闭原则，通常会引入新的抽象层次，增加代码的复杂度。你需要把注意力集中在设计中最有可能改变的地方，然后应用开放-关闭原则。
解决问题：类数量爆炸、设计死板，以及基类加入的新功能并不适用于所有的子类。
关于装饰者模式：
	装饰者和被装饰对象有相同的超类型；
	你可以用一个或多个装饰者包装一个对象；
	既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合，可以用装饰过的对象代替它；
	装饰者可以在所委托被装饰者的行为之前与 / 或之后，加上自己的行为，以达到特定的目的；
	对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。
**********装饰者模式**********
装饰者模式 动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
****************************
如果你把代码写成依赖于具体的组件类型，那么装饰者就会导致程序出问题。只有在针对抽象组件类型编程时，才不会因为装饰者而受到影响。但是，如果的确针对特定的具体组件编程，就应该重新思考你的应用架构，以及装饰者是否适合。

java.io，装饰者模式：
	LineNumberInputStream，加上了计算行数的能力；
	BufferedInputStream，利用缓冲输入来改进性能；用一个readLine()方法（用来一次读取一行文本输入数据）来增强接口。
	FileInpuStream，被装饰的“组件”。

		FileStream
		StringStream
InputStream	ByteArrayInputStream
		FilterInputStream：PushbackStream、BufferedInputStream、DataInputStream、LineNumberInputStream。

缺点：利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，可能会造成使用此API程序员的困扰。
----------总结----------
1. 继承属于扩展形式之一，但不见得是达到弹性设计的最佳方式。
2. 在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码。
3. 组合和委托可用于在运行时动态地加上新的行为。
4. 除了继承，装饰者模式也可以让我们扩展行为。
5. 装饰者模式意味着一群装饰者类，这些类用来包装具体组件。
6. 装饰者类反映出被装饰的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）。
7. 装饰者可以在被装饰者的行为前面与 / 或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。
8. 你可以用无数个装饰者包装一个组件。
9. 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。
10. 装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。

----------------------------------------
chapter 4 工厂模式
--------------------
工厂处理创建对象的细节。
把创建对象代码封装，当以后实现改变时，只需要修改这个类即可。
静态工厂：利用静态方法定义工厂，可以不需要使用创建对象的方法实例化对象，但不能通过继承来改变创建方法的行为。
实现接口并与一定表示写一个类，并利用implement关键词来实现java接口，泛指实现某个超类型的某个方法。
工厂方法是抽象的，所以依赖子类来处理对象的创建，工厂方法必须返回一个产品，超类中定义的方法，通常使用到工厂方法的返回值，工厂方法将客户和市级创建具体产品的代码分离开来，可能需要参数，也可能不需要。
**********工厂方法模式**********
通过让子类决定该创建的对象是什么，来达到对象创建过程封装的目的。
或者
定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个，工厂方法让类把实例化推迟到子类中。
******************************
1. 创建者类
   抽象创建者类，定义了一个抽象的工厂方法，让子类实现此方法制造产品；
   创建者通常会包含依赖抽象产品的代码，而这些抽象产品由子类制造，创建者不需要真的知道在制造哪种具体产品；
   能够产生产品的类成为具体创建者。
2. 产品类
   这些是具体的产品。
工厂方法模式能够封装具体类型的实例化，让子类决定实例化的类是哪一个，但并不是允许子类本身在运行时做决定，而是在编写创建者类时，不需要知道实际创建的产品是哪一个。

**********依赖倒置原则**********
要依赖抽象，不要依赖具体类。
******************************
不能让高层组件依赖底层组件，不管高层或底层组件，两者都应该依赖于抽象。
设计依赖倒置：
	变量不可以具有具体类的引用：如果使用new，就会持有具体类的引用，可以改用工厂模式；
	不要让类派生出自具体类：如果派生来自具体类，就会依赖具体类；
	不要覆盖基类中已实现的方法：如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合该继承的抽象，基类中已经实现的方法，应该有所有子类共享。
**********抽象工厂模式**********
提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
******************************
抽象工厂模式允许客户使用抽象的借口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么。
抽象工厂的任务是定义一个负责创建一组产品的接口，接口内每个方法都负责创建一个具体产品，同时利用实现抽象工厂的子类来提供这些具体的做法。

**********工厂和抽象工厂方法**********
1. 工厂使用的是类，通过继承创建对象，创建对象需要扩展一个类，并覆盖它的工厂方法，通过子类来创建对象，客户只需要知道它所使用的抽象类型就可以创建；
而抽象工厂使用的是对象，通过对象的组合实现，通过产品家族的抽象类型，先实例化，传入到抽象类型代码中，新增扩展比较困难。
抽象工厂：需要创建产品家族和想让制造的相关产品集合起来时使用；
工厂方法：目前不知道将来需要实例化哪些具体类，可以通过继承使用。
----------总结----------
1. 所有工厂都是用来封装对象的创建；
2. 简单工厂，虽然不是真正的设计模式，但仍不失为一个简单的方法，可以将客户程序从具体类中解耦；
3. 工厂方法使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象；
4. 抽象工厂使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中；
5. 所有工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合；
6. 工厂方法允许类将实例化延迟到子类进行；
7. 抽象工厂创建相关的对象家族，而不需要依赖它们的具体类；
8. 依赖倒置原则，指导我们避免依赖具体类型，而要尽量依赖抽象；
9. 工厂是很有威力的技巧，帮助我们针对抽象编程，而不是针对具体类编程。
------------------------
----------------------------------------
chapter 5 单件模式
--------------------
一些只需要一个对象：注册表、线程池、缓存、对话框、偏好设置等，适合单例模式；
可以通过把构造函数声明为private，然后通过static的getInstance()来获取唯一实例。
例子：巧克力工厂
----------单件模式----------
确保只有一个单例，并提供一个全局访问点。
---------------------------
可以避免其他类自行产生实例。
处理多线程：
	只要把getInstance()变为synchronized，迫使每个线程进入方法前，先等候其他线程离开此方法，但会降低性能，只有第一次执行此方法才真正需要同步。
改进方法：
	getInstance()影响较小，忽略；
	在静态初始化器中创建单件；
	***“双层检查加锁”减少同步：首先检查实例是否创建，如果未创建才同步。
	private volatile static Singleton uniqueInstance;
	public static Singleton getInstance(){
	       if(uniqueInstance == null){
	       	  synchronized(Singleton.class){
			if(uniqueInstance == null){
				uniqueInstance = new Singleton();
			}
		  }
	       }
	       return uniqueInstance;
	}
	volatile确保初始化Singleton实例时，多线程正确处理变量。
类加载器：同时使用类加载器和单件模式，自行指定类加载器，并指定同一个类加载器。
在Java 1.2之前垃圾收集器会回收单件，后来bug修复。
继承单件类，构造器是私有的，不能通过私有构造器扩展类，所以必须把单件的构造器改成公开的或受保护的，并且会导致static被所有子类共享，导致其他错误。
全局变量比单件性能差，因为它会导致急切实例化VS延迟实例化，不能保证只有一个实例，造成命名空间的污染。
----------总结----------
1. 单件模式确保程序中一个类最多只有一个实例；
2. 单件模式也提供访问这个实例的全局点；
3. 在Java中实现单件模式需要私有的构造器、一个静态方法和一个静态变量；
4. 确定在性能上和资源上的限制，然后小心的选择适当的方案来实现单件模式，以解决多线程问题；
5. 使用多个类加载器会导致单件模式失效；
------------------------
----------------------------------------
chapter 6 命令模式
--------------------
1. 客户创建一个命令对象；
2. 客户利用setCommand()将命令对象存储在调用者中；
3. 客户要求调用者执行命令。
Client -> Command -> Invoker -> execute() -> Receiver
**********命令模式**********
将“请求”封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象，命令模式也支持可撤销的操作。
***************************
客户负责创建一个具体command，并设置接受者，ConcreteCommand定义了动作和接受者之间的绑定关系，调用者只要调用execute()就可以发出请求。
使用堆栈可以实现多层次撤销。
命令模式：队列请求
工作队列类和进行计算的对象之间是完全解耦的。
线程从队列中一个个删除命令对象，然后调用命令执行。
命令模式：日志请求
在Java中，我们可以利用对象序列化实现根据日志恢复，每个命令加入store()和load()记录日志。
----------总结----------
1. 命令模式将发出请求的对象和执行请求的对象解耦；
2. 在被解耦的两者之间是通过命令对象进行沟通的，命令对象封装了接受者和一个或一组动作；
3. 调用者通过调用命令对象的execute()发出请求，这会使接受者的动作被调用；
4. 调用者可以接受命令当做参数，甚至在运行时动态地进行；
5. 命令可以支持撤销，做法是实现一个undo()方法来回到execute()被执行前的状态；
6. 宏命令是命令的一种简单的延伸，允许调用多个命令。宏方法也可以支持撤销；
7. 实际操作时，很常见使用“聪明”命令对象，也就是直接实现了请求，而不是将工作委托给接受者；
8. 命令也可以用来实现日志和事务系统。
------------------------
----------------------------------------
chapter 7 适配器模式与外观模式
----------------------------------------
适配器模式中，客户是依据目标接口实现的，适配器实现了目标接口，并持有被适配者的实例。
1. 客户通过目标接口调用适配器的方法对适配器发出请求；
2. 适配器使用被适配器接口接口把请求转换成被适配者的一个或多个调用接口；
3. 客户接收到调用的结果，但并未察觉这一切是适配器在起转换作用。
适配器实现很大接口，有很多东西要做。
一个适配器包装多个被适配者，外观模式；
对于部分期望保留旧厂商接口的可以使用双向的适配器。
**********适配者模式**********
将一个类的接口，转换为客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。
*****************************
适配器可以将改变的部分封装起来，客户不必为了应对不同的接口而每次跟着修改。
两种适配器：对象适配器、类适配器。
类适配器不是使用组合来适配被适配者，而是继承被适配者和目标类。
区别：
对象适配器使用组合，更有弹性；
类适配器使用继承，不需要重新实现整个被适配者。
从枚举到迭代器
装配者和适配器：
  装配者工作与责任有关，新行为加入无需修改现有代码；
  适配器提供解耦，允许客户使用新的库和子集合。
外观模式：让接口更简单。
外观只是提供你更直接的操作，并未将原有的子系统阻隔起来，如果你需要子系统类的更高层功能，还是可以使用原来的子系统。
外观没有封装子系统的类，外观只提供简化的接口，简化系统的同时，依然将系统完整功能暴露出来，以供需要的人使用。
外观模式可以附加新增功能，一个子系统可以创建许多外观。
外观模式允许你将客户实现从任何子系统中解耦。
适配器模式可以将一个或多个类接口变成客户所期望的一个接口。
一个外观也可以只针对一个复杂接口的类提供简化的接口，适配器模式意图改变接口符合客户的期望，外观模式意图提供子系统的一个简化的接口。
**********外观模式**********
提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。
***************************
----------最少知识原则（喷墨式原则）----------
只和你的密友谈话。
---------------------------
当你正在设计一个系统，不管是任何对象，你都要注意它所交互的类有哪些，并注意它和这些类是如何交互的。这个原则希望我们在设计中，不要让太多的类耦合在一起，免得修改系统中的一部分，会影响到其他部分，如果许多类之间相互依赖，那么这个系统就会变成一个易碎的系统，需要更多的成本维护。
在对象方法中，只调用以下方法：
  该对象本身；
  被当做方法的参数而传递进来的对象；
  此方法所创建或所实例化的任何对象；
  对象的任何组件。
如果某对象是调用其他的方法的返回结果，不要调用该对象的方法。
把“组件”想象为是被实例变量所引用的任何对象，把这想象成HAS-A关系。
缺点：导致更多的“包装”类被制造出来，以处理和其他组件的沟通，可能导致复杂度和开发时间增加，降低运行时的性能。
---------------总结---------------
1. 当需要使用一个现有的类而其接口并不符合你的需要时，就使用适配器；
2. 当需要简化并统一一个很大的接口或者一群复杂的接口时，使用外观；
3. 适配器改变接口以符合客户的期望；
4. 外观将客户从一个复杂的子系统中解耦；
5. 实现一个适配器复杂度根据目标接口的大小与其复杂度而定；
6. 实现一个外观，需要将子系统组合进外观中，然后将工作委托给子系统执行；
7. 适配器两种模式：类适配器、对象适配器；
8. 可以为一个子系统实现一个以上的外观；
9. 适配器讲一个对象包装起来以改变其接口；装饰者将一个对象包装起来以增加新的行为和责任；而外观将一群对象包装起来以简化其接口。
----------------------------------
----------------------------------------
chapter 8 模板方法模式 封装算法
--------------------
找出共同点。
需要由子类提供的方法，必须在超类中声明为抽象；
模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。
---------------模板方法模式---------------
在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。
-----------------------------------------
hook是一种被声明在抽象类中的方法，但只有空的或者默认的实现。钩子的存在可以让子类有能力对算法的不同点进行挂钩。
当你的子类“必须”提供算法中某个方法或步骤的实现时，使用抽象方法，如果算法中的这个部分是可选的，就用钩子。如果是钩子的话，子类可以选择实现这个钩子，并不强制做。
钩子用法：
  钩子可以让子类实现算法中可选的部分，或者在钩子对于子类的实现并不重要的时候，子类可以不处理钩子；
  让子类能够有机会对模板方法中某些即将发生的步骤做出反应。
模板方法中子类必须实现抽象类中所有方法。
---------------好莱坞原则---------------
别调用我们，我们会调用你。
---------------------------------------
底层组件绝不可以直接调用高层组件。
依赖倒置原则教我们尽量避免使用具体类，而多使用抽象；
好莱坞原则是在创建框架或组件上的一种技巧，创建一个有弹性的设计，允许底层结构能够互相操作，而又防止其他类太过依赖它们。
----------
模板方法：子类决定如何实现算法中的步骤；
策略：封装可互换的行为，然后使用委托来决定要采用哪一个行为；
工厂方法：由子类决定实例化哪个具体类。
----------
如使用duck implements Comparable完成对对象duck排序。
---------------总结---------------
1. 模板方法定义了算法的步骤，把这些步骤的实现延迟到子类中；
2. 模板方法模式为我们提供了一种代码复用的重要技巧；
3. 模板方法的抽象类可以定义具体方法，抽象方法和钩子；
4. 抽象方法由子类实现；
5. 钩子是一种方法，它在抽象类中不做事，或者只做默认的事情，子类可以选择要不要去覆盖它；
6. 为了防止子类改变模板方法中的算法，可以将模板声明为final；
7. 好莱坞原则将决策权放在高层模块中，以便决定如何以及何时调用底层模块；
8. 策略方法和模板方法都封装方法，一个用组合，一个用继承；
9. 工厂方法是模板方法的一种特殊版本。
-----------------------------------
----------------------------------------
chapter 9 迭代器与组合模式
--------------------
interface Iterator{
  boolean hasNext();
  Object next();
}
迭代器：只需要一个循环就可以多态地处理任何项的集合
---------------迭代器模式---------------
提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示。
---------------------------------------
外部迭代器，客户通过调用next()取得下一个元素；
内部迭代器，迭代器自己控制，必须告诉迭代器在游走过程中，做些什么事情，必须将操作传入给迭代器。
---------------单一责任---------------
一个类应该只有一个引起变化的原因。
-------------------------------------
每个类保持单一责任。
---------------内聚---------------
高内聚：当一个模块或一个类被设计成只支持一组相关的功能时；
低内聚：当被设计成支持一组不相关的功能时。
----------------------------------
Hashtable对于迭代器的支持是“间接的”，从中取元素不是直接去除，而是在它的value取出的。
Collection和Iterator优点：每个Collection都知道如何创建自己的Iterator，只要调用ArrayList上的itreator()，就可以返回一个迭代器。
for(Object obj:collection){
  //
}
对于菜单例子，当需要在餐厅菜单中加入甜点菜单，需要改变：
  需要某种树形结构；
  需要能够在各个菜单各个项之间方便游走；
  需要能够更有弹性地在菜单项之间游走。
---------------组合模式---------------
允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。
-------------------------------------
组合模式让我们能用树形方式创建对象的结构，树里面包含了组合以及个别的对象。
使用组合结构，我们能把相同的操作应用在组合和个别对象上，可以忽略对象组合和个别对象之间的差别。
组合、组件、树
  组合包含组件，组件有两种：组合与叶节点元素。
组合模式以单一责任设计原则换区透明性。
对于Menu：
public Iterator createIterator(){
  return new CompositeIterator(menuComponents.iterator());
}
对于MenuItem
public Iterator createIterator(){
  return new NullIterator();
}
组合迭代器：
--------------------
public class CompositeIterator implements Iterator{
  Stack stack = new Stack();
  public CompositeIterator(Iterator iterator){
    stack.push();
  }
  public Object next(){
    if(hasNext()){
      Iterator iterator = (Iterator)stack.peek();
      MenuComponent component = (MenuComponent)iterator.next();
      if(component instanceof Menu){
        stack.push(component.createIterator());
      }
      }else{
        return null;
      }
  }
  public boolean hasNext(){
    if(stack.empty()){
      return false;
    }else{
      Iterator iterator = (Iterator)stack.peek();
      if(!iterator.hasNext()){
        stack.pop();
	return hasNext();
      }else{
        return true;
      }
    }
  }
  public void remove(){
    throw new Exception();
  }
}
--------------------
空迭代器 NullIterator
  对于返回null值，可替代选择是将其hasNext()永远返回false。
组合：通常是树形结构，即层次结构，根是顶层的组合，然后往下是它的孩子，最末端是叶节点。
可以利用缓存提高组合遍历效率。
---------------总结---------------
1. 迭代器允许访问聚合的元素，而不需要暴露它的内部结构；
2. 迭代器将遍历聚合的工作封装进一个对象中；
3. 当使用迭代器的时候，我们依赖聚合提供遍历；
4. 迭代器提供一个通用的接口，让我们遍历聚合项，当我们编码使用聚合的项时，就可以使用多态机制；
5. 我们应该努力让一个类只分配一个责任；
6. 组合模式提供一个结构，可同时包容个别对象的组合对象；
7. 组合模式允许客户对个别对象同时包容个别对象的组合对象；
8. 组合模式允许客户对个别对象以及组合对象一视同仁；
9. 组合结构内的任意对象称为组件，组件可以是组合，也可以是叶节点；
10. 在实现组合模式时，有许多设计上的折中，要平衡透明性和安全性。
-----------------------------------
--------------------chapter 10 状态模式--------------------
策略模式和状态模式是双胞胎。
设计：
  首先，定义一个State接口；
  然后为机器中的每个状态实现状态类；
  最后，将动作委托到状态类。
定义状态接口和类
  首先创建一个State接口，所有状态都必须实现这个接口；
  然后将设计中的每个状态都封装成一个类，每个都实现State接口。
---------------状态模式---------------
允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
-------------------------------------
状态模式：将一群行为封装在状态对象中，context的行为随时可委托到那些状态对象中的一个。随着时间流逝，当前状态在状态对象集合中游走改变，以反映context内部状态，context的行为也会随着改变，但是context的客户对于状态对象了解不多。
策略模式：客户通常主动指定Context所要组合的策略对象是哪一个；把策略模式想成除了继承之外的一种弹性替代方案，把状态模式想成不用context中放置许多条件判断的替代方案。
状态模式中，状态是用在Context中来代表它的内部状态以及行为的，所以只有Context才会对状态提出请求，客户不会直接改变Context的状态；且共享状态实例。
---------------总结---------------
1. 状态模式允许一个对象基于内部状态而拥有不同的行为；
2. 和程序状态机（PSM）不同，状态模式用类代表状态；
3. Context会将行为委托给当前状态对象；
4. 通过将每个状态封装进一个类，我们把以后需要做的任何改变局部化；
5. 状态模式和策略模式有相同的类图，但是它们的意图不同；
6. 策略模式通常会行为或算法来配置Context；
7. 状态模式允许Context随着状态的改变而改变行为；
8. 状态转换可以由State类或Context类控制；
9. 使用状态模式通常会导致设计类的数目大量增加；
10. 状态类可以被多个Context实例共享。
------------------------------------
-------------------------chapter 11 代理模式-------------------------
代理可以假装自己是远程对象，但其实只是一个中间的角色。
客户对象所做的就像是在做远程方法调用，但其实只是调用本地堆的“代理”对象上的方法，再由代理处理所有网络通信的底层细节。
Duck d = <另一个堆的对象>
使用RMI进行创建。
---------------远程方法---------------
客户辅助对象会乔装为服务对象，但是不是真正的远程服务，并不真正拥有远程服务的方法和逻辑，客户辅助对象会联系服务器，传入方法调用信息，等待服务器返回。
服务器端，服务辅助对象通过Socket接受请求，将调用信息解包，然后调用真正服务对象的真正方法，得到返回值，打包，返回客户辅助对象，客户辅助对象对信息解包，最后将返回值交给客户对象。
这里客户辅助对象是个代理。
---------------RMI概观---------------
RMI提供了客户辅助对象和服务器辅助对象，为辅助对象创建和服务对象相同的方法，可以不用亲自写任何网络或I/O代码。
查找服务：用来寻找和访问远程对象。
客户辅助对象：RMI STUB；
服务辅助对象：RMI SKELETON。
----------制作远程服务----------
-----步骤一：制作远程接口-----
远程接口定义出可以让客户远程调用的方法，客户将用它作为服务的类类型，Stub和实际的服务都实现此接口。
1. 扩展java.rmi.Remote
Remote不具有方法；
public interface MyRemote extends Remote
2. 声明所有方法都会抛出RemoteException
客户会调用实现远程接口的Stub上的方法，Stub底层用到了网络和I/O，所以有风险，必须处理或声明远程异常来解决，如果接口中声明了异常，任何在接口类型的引用上调用方法的代码也必须处理或者声明异常。
3. 确定变量和返回值属于原语类型或者可序列化
远程方法的变量和返回值必须是原语类型或Serializable类型。
-----步骤二：制作远程的实现-----
实际工作类，提供真正的实现。
1. 实现远程接口
客户将要调用的方法的接口。
2. 扩展UnicastRemoteObject
使对象具有远程的功能，扩展java.rmi.UnicastRemoteObject。
3. 设计一个不带变量的构造器，声明RemoteException
超类抛出异常，子类也抛出。
4. 注册RMI Registry服务
将服务实例化，然后放进RMI registry中。
java.rmi.Naming.rebind();
-----步骤三：利用rmic产生的stub和skeleton-----
客户和服务的辅助类。
在远程实现类上执行rmic。
rmic MyRemoteImpl
-----步骤四：启动RMI registry-----
用户可以从中查找代理位置。
开启终端，启动rmiregistry，启动目录可以访问类，从classes目录启动。
-----步骤五：开始远程服务-----
服务对象运行，服务类会实例化一个服务实例，并将服务注册到RMI registry。
启动服务。
--------------------------------
----------客户获取stub对象----------
使用RMI Registry获取，如下：
MyRemote service = (MyRemote) Naming.lookup("rmi://127.0.0.1/RemoteHello");
实际上不需要知道远程服务真正类名。
-----工作方式-----
1. 客户到RMI registry中寻找
Naming.lookup();
2. RMI registry返回Stub对象
RMI会自动反序列化，客户端必须有stub类，否则无法反序列化。
3. 客户调用Stub的方法。
扩展：动态类下载，发现没有本地类，会使用HTTP的GET获取类文件。
注意：
1. 启动远程服务之前启动rmiregistry；
2. 不要忘记变量和返回值的类型成为可序列化类型；
3. 客户端也需要stub，但不引用stub类。
--------------------
public interface State extends Serializable{
}
public class NoQuarterState implements State{
  transient GumballMachine gumballMachine;
  //不序列化
}
----------过程----------
1. 先通过RMI registry取得代理；
2. 然后调用方法，通过Stub调用被转向远程服务，Skeleton收到请求，发给远程实现类；
3. 远程实现类将结果返回给skeleton，然后序列化，通过网络传回客户端代理。
----------代理模式----------
代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问。
---------------------------
代理方式变体：
  远程代理控制访问远程对象；
  虚拟代理控制访问创建开销大的资源；
  保护代理基于权限控制对资源的访问。
代理负责远程实现类的创建与销毁，控制了访问。
---------------虚拟代理---------------
虚拟代理作为创建开销大的对象的代表，虚拟代理经常知道我们真正需要一个对象的时候才创建它，当对象创建前或创建中，虚拟代理扮演对象本身，创建后代理会将请求直接委托给对象。
如在线音乐显示CD封面，在网络图片加载出来之前，再是显示其他默认图片。
----------ImageProxy----------
1. ImageProxy首先创建一个ImageIcon，然后开始从网络上获取图像；
2. Imageproxy显示加载中；
3. 加载完毕，调用委托给真正的ImageIcon；
4. 重复此类过程。
------------------------------
缓存代理：会维护之前创建的对象，当收到请求时，在可能的情况下返回缓存对象。
-----装饰者模式和代理模式-----
装饰者模式为对象增加行为，代理模式是控制对象的访问；
可以使用工厂模式，实例化并返回主题，可以让客户使用代理而不是真正的对象，但客户并不知道。
----------------------------
-----适配器模式和代理模式-----
都是挡在其他对象的前面，并负责将请求转发给它们，适配器会改变对象适配的接口，代理则实现相同的接口。
保护代理：可以根据客户角色决定客户访问特定方法。
---------------------------
----------保护代理----------
动态代理：使用java.lang.reflect，动态创建代理类。
PersonBean{
String name;
String gender;
String interests;
int rating;
int ratingCount = 0;
}
顾客不可以改变自己的HotOrNot评分，也不可以改变他人的信息。一次创建两个代理：
一个访问自己的PersonBean对象；另一个访问另一个顾客的PersonBean。
---------------
动态代理：并不是运行时实例化，运行时才将它的类创建出来，代码执行时，没有proxy类，它是根据需要从传入的接口集创建的。
代理类静态方法isProxyClass()判断是否为代理类，代理类会实现特定的某些接口。
传入的newProxyInstance()接口类型限制：接口数组中只能有接口不能有类，如果接口不是public，就必须是同一个package，不同的接口内，不可以有名称和参数完全一样的方法。
为什么使用skeleton：概念上帮助理解。
Java 5中stub不需要产生：RMI和动态代理搭配使用，动态代理产生stub，远程对象的stub是java.lang.reflect.Proxy实例，自动产生，来处理所有把客户的本地调用变成远程调用的细节。
---------------
防火墙代理：控制网络资源的访问，保护主题免于“坏用户”的侵害。
智能引用代理：当主题被引用时，进行额外的动作，例如计算一个对象被引用的次数。
缓存代理：为开销大的运算结构提供暂时储存：它允许多个客户共享结果，以减少计算或网络延迟。
同步代理：在多线程的情况下为主题提供安全的访问。
复杂隐藏代理：用来隐藏一个类的复杂集合的复杂度，并进行访问控制。有时也称为外观代理。
写入时复制代理：用来控制对象的复制，方法是延迟对象的复制，直到客户真的需要为止，虚拟代理的变体。
---------------总结---------------
1. 代理模式为另一个对象提供代表，以便控制客户对对象的访问，管理访问的方式有许多种。
2. 远程代理管理客户和远程对象之间的交互。
3. 虚拟代理控制访问实例化开销大的对象。
4. 保护代理基于调用者控制对象方法的访问。
5. 代理在结构上类似装饰者，但是目的不同。
6. 装饰者模式为对象加上行为，而代理则是控制访问。
7. Java内置的代理支持，可以根据需要建立动态代理，并将所有调用分配到所选的处理器。
8. 代理会造成设计类数目增加。
-----------------------------------
--------------------chapter 12 复合模式 模式的模式--------------------

